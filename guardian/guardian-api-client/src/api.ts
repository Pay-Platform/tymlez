/* tslint:disable */
/* eslint-disable */
/**
 * Guardian
 * The Guardian is a modular open-source solution that includes best-in-class identity management and decentralized ledger technology (DLT) libraries. At the heart of the Guardian solution is a sophisticated Policy Workflow Engine (PWE) that enables applications to offer a requirements-based tokenization implementation.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: info@envisionblockchain.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from './base';

/**
 *
 * @export
 * @interface Account
 */
export interface Account {
  /**
   *
   * @type {string}
   * @memberof Account
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  role: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  did?: string;
}
/**
 *
 * @export
 * @interface CommonSettings
 */
export interface CommonSettings {
  /**
   *
   * @type {string}
   * @memberof CommonSettings
   */
  operatorId?: string;
  /**
   *
   * @type {string}
   * @memberof CommonSettings
   */
  operatorKey?: string;
  /**
   *
   * @type {string}
   * @memberof CommonSettings
   */
  nftApiKey?: string;
}
/**
 *
 * @export
 * @interface Credentials
 */
export interface Credentials {
  /**
   *
   * @type {string}
   * @memberof Credentials
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof Credentials
   */
  password: string;
}
/**
 *
 * @export
 * @interface ExportPolicy
 */
export interface ExportPolicy {
  /**
   *
   * @type {string}
   * @memberof ExportPolicy
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ExportPolicy
   */
  version: string;
  /**
   *
   * @type {string}
   * @memberof ExportPolicy
   */
  tokens?: string;
}
/**
 *
 * @export
 * @interface ExportSchema
 */
export interface ExportSchema {
  /**
   *
   * @type {string}
   * @memberof ExportSchema
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ExportSchema
   */
  version?: string;
  /**
   *
   * @type {string}
   * @memberof ExportSchema
   */
  messageId?: string;
}
/**
 *
 * @export
 * @interface ExternalData
 */
export interface ExternalData {
  /**
   *
   * @type {string}
   * @memberof ExternalData
   */
  owner: string;
  /**
   *
   * @type {string}
   * @memberof ExternalData
   */
  policyTag: string;
  /**
   *
   * @type {object}
   * @memberof ExternalData
   */
  document: object;
}
/**
 *
 * @export
 * @interface HederaAccount
 */
export interface HederaAccount {
  /**
   *
   * @type {string}
   * @memberof HederaAccount
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof HederaAccount
   */
  key: string;
}
/**
 *
 * @export
 * @interface ImportSchema
 */
export interface ImportSchema {
  /**
   *
   * @type {Array<ImportSchemaSchemes>}
   * @memberof ImportSchema
   */
  schemes: Array<ImportSchemaSchemes>;
}
/**
 *
 * @export
 * @interface ImportSchemaSchemes
 */
export interface ImportSchemaSchemes {
  /**
   *
   * @type {string}
   * @memberof ImportSchemaSchemes
   */
  document: string;
  /**
   *
   * @type {string}
   * @memberof ImportSchemaSchemes
   */
  entity: string;
  /**
   *
   * @type {string}
   * @memberof ImportSchemaSchemes
   */
  hash?: string;
  /**
   *
   * @type {string}
   * @memberof ImportSchemaSchemes
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ImportSchemaSchemes
   */
  uuid: string;
}
/**
 *
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
  /**
   *
   * @type {string}
   * @memberof InlineObject
   */
  version?: string;
}
/**
 *
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
  /**
   *
   * @type {string}
   * @memberof InlineObject1
   */
  messageId?: string;
}
/**
 *
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
  /**
   *
   * @type {string}
   * @memberof InlineObject2
   */
  messageId?: string;
}
/**
 *
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
  /**
   *
   * @type {string}
   * @memberof InlineObject3
   */
  messageId?: string;
}
/**
 *
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
  /**
   *
   * @type {string}
   * @memberof InlineObject4
   */
  policyVersion?: string;
}
/**
 *
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
  /**
   *
   * @type {string}
   * @memberof InlineObject5
   */
  messageId?: string;
}
/**
 *
 * @export
 * @interface InlineObject6
 */
export interface InlineObject6 {
  /**
   *
   * @type {string}
   * @memberof InlineObject6
   */
  messageId?: string;
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse200
   */
  id?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
  /**
   *
   * @type {number}
   * @memberof InlineResponse2001
   */
  totalCount?: number;
  /**
   *
   * @type {Log}
   * @memberof InlineResponse2001
   */
  logs?: Log;
}
/**
 *
 * @export
 * @interface Log
 */
export interface Log {
  /**
   *
   * @type {string}
   * @memberof Log
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof Log
   */
  datetime?: string;
  /**
   *
   * @type {string}
   * @memberof Log
   */
  message?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Log
   */
  attributes?: Array<string>;
}
/**
 *
 * @export
 * @interface LogFilters
 */
export interface LogFilters {
  /**
   *
   * @type {string}
   * @memberof LogFilters
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof LogFilters
   */
  startDate?: string;
  /**
   *
   * @type {string}
   * @memberof LogFilters
   */
  endDate?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof LogFilters
   */
  attributes?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof LogFilters
   */
  message?: string;
  /**
   *
   * @type {number}
   * @memberof LogFilters
   */
  pageSize?: number;
  /**
   *
   * @type {number}
   * @memberof LogFilters
   */
  pageIndex?: number;
  /**
   *
   * @type {string}
   * @memberof LogFilters
   */
  sortDirection?: LogFiltersSortDirectionEnum;
}

export const LogFiltersSortDirectionEnum = {
  Asc: 'ASC',
  Desc: 'DESC',
} as const;

export type LogFiltersSortDirectionEnum =
  typeof LogFiltersSortDirectionEnum[keyof typeof LogFiltersSortDirectionEnum];

/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   *
   * @type {number}
   * @memberof ModelError
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  message: string;
}
/**
 *
 * @export
 * @interface PolicyBlock
 */
export interface PolicyBlock {
  /**
   *
   * @type {string}
   * @memberof PolicyBlock
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof PolicyBlock
   */
  blockType: string;
  /**
   *
   * @type {boolean}
   * @memberof PolicyBlock
   */
  isActive: boolean;
  /**
   *
   * @type {object}
   * @memberof PolicyBlock
   */
  uiMetaData: object;
  /**
   *
   * @type {Array<object>}
   * @memberof PolicyBlock
   */
  blocks?: Array<object>;
}
/**
 *
 * @export
 * @interface PolicyBlockData
 */
export interface PolicyBlockData {
  /**
   *
   * @type {string}
   * @memberof PolicyBlockData
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof PolicyBlockData
   */
  blockType?: string;
  /**
   *
   * @type {boolean}
   * @memberof PolicyBlockData
   */
  isActive: boolean;
  /**
   *
   * @type {object}
   * @memberof PolicyBlockData
   */
  uiMetaData: object;
  /**
   *
   * @type {object}
   * @memberof PolicyBlockData
   */
  data: object;
  /**
   *
   * @type {Array<object>}
   * @memberof PolicyBlockData
   */
  fields?: Array<object>;
  /**
   *
   * @type {number}
   * @memberof PolicyBlockData
   */
  index?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof PolicyBlockData
   */
  roles?: Array<string>;
  /**
   *
   * @type {Array<PolicyBlock>}
   * @memberof PolicyBlockData
   */
  blocks?: Array<PolicyBlock>;
}
/**
 *
 * @export
 * @interface PolicyConfig
 */
export interface PolicyConfig {
  /**
   *
   * @type {string}
   * @memberof PolicyConfig
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof PolicyConfig
   */
  uuid?: string;
  /**
   *
   * @type {string}
   * @memberof PolicyConfig
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof PolicyConfig
   */
  version: string;
  /**
   *
   * @type {string}
   * @memberof PolicyConfig
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof PolicyConfig
   */
  topicDescription: string;
  /**
   *
   * @type {object}
   * @memberof PolicyConfig
   */
  config: object;
  /**
   *
   * @type {string}
   * @memberof PolicyConfig
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof PolicyConfig
   */
  owner?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof PolicyConfig
   */
  policyRoles?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof PolicyConfig
   */
  topicId: string;
  /**
   *
   * @type {string}
   * @memberof PolicyConfig
   */
  policyTag: string;
  /**
   *
   * @type {Array<PolicyConfigPolicyTopics>}
   * @memberof PolicyConfig
   */
  policyTopics?: Array<PolicyConfigPolicyTopics>;
}
/**
 *
 * @export
 * @interface PolicyConfigPolicyTopics
 */
export interface PolicyConfigPolicyTopics {
  /**
   *
   * @type {string}
   * @memberof PolicyConfigPolicyTopics
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof PolicyConfigPolicyTopics
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof PolicyConfigPolicyTopics
   */
  type?: string;
  /**
   *
   * @type {boolean}
   * @memberof PolicyConfigPolicyTopics
   */
  static?: boolean;
}
/**
 *
 * @export
 * @interface PreviewPolicy
 */
export interface PreviewPolicy {
  /**
   *
   * @type {object}
   * @memberof PreviewPolicy
   */
  policy: object;
  /**
   *
   * @type {Array<object>}
   * @memberof PreviewPolicy
   */
  schemas: Array<object>;
  /**
   *
   * @type {Array<object>}
   * @memberof PreviewPolicy
   */
  tokens: Array<object>;
}
/**
 *
 * @export
 * @interface PublishPolicy
 */
export interface PublishPolicy {
  /**
   *
   * @type {Array<object>}
   * @memberof PublishPolicy
   */
  errors: Array<object>;
  /**
   *
   * @type {boolean}
   * @memberof PublishPolicy
   */
  isValid: boolean;
  /**
   *
   * @type {Array<object>}
   * @memberof PublishPolicy
   */
  policies: Array<object>;
}
/**
 *
 * @export
 * @interface Schema
 */
export interface Schema {
  /**
   *
   * @type {string}
   * @memberof Schema
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Schema
   */
  iri?: string;
  /**
   *
   * @type {string}
   * @memberof Schema
   */
  uuid?: string;
  /**
   *
   * @type {string}
   * @memberof Schema
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Schema
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof Schema
   */
  entity: string;
  /**
   *
   * @type {string}
   * @memberof Schema
   */
  hash?: string;
  /**
   *
   * @type {string}
   * @memberof Schema
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof Schema
   */
  document: string;
  /**
   *
   * @type {string}
   * @memberof Schema
   */
  topicId?: string;
  /**
   *
   * @type {string}
   * @memberof Schema
   */
  version?: string;
  /**
   *
   * @type {string}
   * @memberof Schema
   */
  owner?: string;
  /**
   *
   * @type {string}
   * @memberof Schema
   */
  messageId?: string;
}
/**
 *
 * @export
 * @interface Session
 */
export interface Session {
  /**
   *
   * @type {string}
   * @memberof Session
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof Session
   */
  role: string;
  /**
   *
   * @type {string}
   * @memberof Session
   */
  accessToken: string;
}
/**
 *
 * @export
 * @interface Token
 */
export interface Token {
  /**
   *
   * @type {boolean}
   * @memberof Token
   */
  changeSupply: boolean;
  /**
   *
   * @type {string}
   * @memberof Token
   */
  decimals: string;
  /**
   *
   * @type {boolean}
   * @memberof Token
   */
  enableAdmin: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Token
   */
  enableFreeze: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Token
   */
  enableKYC: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Token
   */
  enableWipe: boolean;
  /**
   *
   * @type {string}
   * @memberof Token
   */
  initialSupply: string;
  /**
   *
   * @type {string}
   * @memberof Token
   */
  tokenName: string;
  /**
   *
   * @type {string}
   * @memberof Token
   */
  tokenSymbol: string;
  /**
   *
   * @type {string}
   * @memberof Token
   */
  tokenType: string;
}
/**
 *
 * @export
 * @interface TokenInfo
 */
export interface TokenInfo {
  /**
   *
   * @type {string}
   * @memberof TokenInfo
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof TokenInfo
   */
  tokenId: string;
  /**
   *
   * @type {string}
   * @memberof TokenInfo
   */
  tokenName: string;
  /**
   *
   * @type {string}
   * @memberof TokenInfo
   */
  tokenSymbol: string;
  /**
   *
   * @type {string}
   * @memberof TokenInfo
   */
  tokenType: string;
  /**
   *
   * @type {string}
   * @memberof TokenInfo
   */
  decimals: string;
  /**
   *
   * @type {boolean}
   * @memberof TokenInfo
   */
  associated: boolean;
  /**
   *
   * @type {string}
   * @memberof TokenInfo
   */
  balance: string;
  /**
   *
   * @type {boolean}
   * @memberof TokenInfo
   */
  frozen: boolean;
  /**
   *
   * @type {boolean}
   * @memberof TokenInfo
   */
  kyc: boolean;
}
/**
 *
 * @export
 * @interface TrustChains
 */
export interface TrustChains {
  /**
   *
   * @type {Array<TrustChainsChain>}
   * @memberof TrustChains
   */
  chain: Array<TrustChainsChain>;
  /**
   *
   * @type {Array<TrustChainsUserMap>}
   * @memberof TrustChains
   */
  userMap: Array<TrustChainsUserMap>;
}
/**
 *
 * @export
 * @interface TrustChainsChain
 */
export interface TrustChainsChain {
  /**
   *
   * @type {string}
   * @memberof TrustChainsChain
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof TrustChainsChain
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof TrustChainsChain
   */
  tag: string;
  /**
   *
   * @type {string}
   * @memberof TrustChainsChain
   */
  label: string;
  /**
   *
   * @type {string}
   * @memberof TrustChainsChain
   */
  schema: string;
  /**
   *
   * @type {string}
   * @memberof TrustChainsChain
   */
  owner: string;
  /**
   *
   * @type {object}
   * @memberof TrustChainsChain
   */
  document: object;
}
/**
 *
 * @export
 * @interface TrustChainsUserMap
 */
export interface TrustChainsUserMap {
  /**
   *
   * @type {string}
   * @memberof TrustChainsUserMap
   */
  did: string;
  /**
   *
   * @type {string}
   * @memberof TrustChainsUserMap
   */
  username: string;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  confirmed?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  failed?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  role: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  hederaAccountId?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  hederaAccountKey?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  did?: string;
  /**
   *
   * @type {object}
   * @memberof User
   */
  didDocument?: object;
  /**
   *
   * @type {object}
   * @memberof User
   */
  vcDocument?: object;
  /**
   *
   * @type {string}
   * @memberof User
   */
  parent?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  topicId?: string;
}
/**
 *
 * @export
 * @interface ValidatePolicy
 */
export interface ValidatePolicy {
  /**
   *
   * @type {object}
   * @memberof ValidatePolicy
   */
  config: object;
  /**
   *
   * @type {object}
   * @memberof ValidatePolicy
   */
  results: object;
}
/**
 *
 * @export
 * @interface VerifiablePresentation
 */
export interface VerifiablePresentation {
  /**
   *
   * @type {string}
   * @memberof VerifiablePresentation
   */
  hash: string;
  /**
   *
   * @type {string}
   * @memberof VerifiablePresentation
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof VerifiablePresentation
   */
  policyId: string;
  /**
   *
   * @type {string}
   * @memberof VerifiablePresentation
   */
  signature: string;
  /**
   *
   * @type {string}
   * @memberof VerifiablePresentation
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof VerifiablePresentation
   */
  tag: string;
  /**
   *
   * @type {string}
   * @memberof VerifiablePresentation
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof VerifiablePresentation
   */
  updateDate: string;
  /**
   *
   * @type {string}
   * @memberof VerifiablePresentation
   */
  createDate: string;
  /**
   *
   * @type {string}
   * @memberof VerifiablePresentation
   */
  owner: string;
  /**
   *
   * @type {object}
   * @memberof VerifiablePresentation
   */
  document: object;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns all users except those with roles Root Authority and Auditor. Only users with the Root Authority role are allowed to make the request.
     * @summary Returns a list of users, excluding Root Authority and Auditors.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountsGet: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Logs user into the system.
     * @param {Credentials} credentials Object that contains username and password fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountsLoginPost: async (
      credentials: Credentials,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'credentials' is not null or undefined
      assertParamExists('accountsLoginPost', 'credentials', credentials);
      const localVarPath = `/accounts/login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        credentials,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Registers a new user account.
     * @param {Credentials} credentials Object that contain username, password and role (optional) fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountsRegisterPost: async (
      credentials: Credentials,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'credentials' is not null or undefined
      assertParamExists('accountsRegisterPost', 'credentials', credentials);
      const localVarPath = `/accounts/register`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        credentials,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns all root authorities.
     * @summary Returns all root authorities.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountsRootAuthoritiesGet: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/accounts/root-authorities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns current user session.
     * @summary Returns current session of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountsSessionGet: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/accounts/session`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns all users except those with roles Root Authority and Auditor. Only users with the Root Authority role are allowed to make the request.
     * @summary Returns a list of users, excluding Root Authority and Auditors.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async accountsGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.accountsGet(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Logs user into the system.
     * @param {Credentials} credentials Object that contains username and password fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async accountsLoginPost(
      credentials: Credentials,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.accountsLoginPost(credentials, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Registers a new user account.
     * @param {Credentials} credentials Object that contain username, password and role (optional) fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async accountsRegisterPost(
      credentials: Credentials,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.accountsRegisterPost(
          credentials,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns all root authorities.
     * @summary Returns all root authorities.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async accountsRootAuthoritiesGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.accountsRootAuthoritiesGet(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns current user session.
     * @summary Returns current session of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async accountsSessionGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.accountsSessionGet(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AccountsApiFp(configuration);
  return {
    /**
     * Returns all users except those with roles Root Authority and Auditor. Only users with the Root Authority role are allowed to make the request.
     * @summary Returns a list of users, excluding Root Authority and Auditors.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountsGet(options?: any): AxiosPromise<Array<Account>> {
      return localVarFp
        .accountsGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Logs user into the system.
     * @param {Credentials} credentials Object that contains username and password fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountsLoginPost(
      credentials: Credentials,
      options?: any,
    ): AxiosPromise<Session> {
      return localVarFp
        .accountsLoginPost(credentials, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Registers a new user account.
     * @param {Credentials} credentials Object that contain username, password and role (optional) fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountsRegisterPost(
      credentials: Credentials,
      options?: any,
    ): AxiosPromise<Account> {
      return localVarFp
        .accountsRegisterPost(credentials, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns all root authorities.
     * @summary Returns all root authorities.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountsRootAuthoritiesGet(options?: any): AxiosPromise<Array<Account>> {
      return localVarFp
        .accountsRootAuthoritiesGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns current user session.
     * @summary Returns current session of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountsSessionGet(options?: any): AxiosPromise<Session> {
      return localVarFp
        .accountsSessionGet(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
  /**
   * Returns all users except those with roles Root Authority and Auditor. Only users with the Root Authority role are allowed to make the request.
   * @summary Returns a list of users, excluding Root Authority and Auditors.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public accountsGet(options?: AxiosRequestConfig) {
    return AccountsApiFp(this.configuration)
      .accountsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Logs user into the system.
   * @param {Credentials} credentials Object that contains username and password fields.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public accountsLoginPost(
    credentials: Credentials,
    options?: AxiosRequestConfig,
  ) {
    return AccountsApiFp(this.configuration)
      .accountsLoginPost(credentials, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Registers a new user account.
   * @param {Credentials} credentials Object that contain username, password and role (optional) fields.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public accountsRegisterPost(
    credentials: Credentials,
    options?: AxiosRequestConfig,
  ) {
    return AccountsApiFp(this.configuration)
      .accountsRegisterPost(credentials, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all root authorities.
   * @summary Returns all root authorities.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public accountsRootAuthoritiesGet(options?: AxiosRequestConfig) {
    return AccountsApiFp(this.configuration)
      .accountsRootAuthoritiesGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns current user session.
   * @summary Returns current session of the user.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public accountsSessionGet(options?: AxiosRequestConfig) {
    return AccountsApiFp(this.configuration)
      .accountsSessionGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DemoApi - axios parameter creator
 * @export
 */
export const DemoApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Generates a new Hedera account with a random private key.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    demoRandomKeyGet: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/demo/randomKey`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns all registered user accounts.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    demoRegisteredUsersGet: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/demo/registeredUsers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DemoApi - functional programming interface
 * @export
 */
export const DemoApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DemoApiAxiosParamCreator(configuration);
  return {
    /**
     * Generates a new Hedera account with a random private key.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async demoRandomKeyGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<HederaAccount>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.demoRandomKeyGet(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns all registered user accounts.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async demoRegisteredUsersGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<Account & object>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.demoRegisteredUsersGet(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * DemoApi - factory interface
 * @export
 */
export const DemoApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DemoApiFp(configuration);
  return {
    /**
     * Generates a new Hedera account with a random private key.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    demoRandomKeyGet(options?: any): AxiosPromise<HederaAccount> {
      return localVarFp
        .demoRandomKeyGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns all registered user accounts.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    demoRegisteredUsersGet(
      options?: any,
    ): AxiosPromise<Array<Account & object>> {
      return localVarFp
        .demoRegisteredUsersGet(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DemoApi - object-oriented interface
 * @export
 * @class DemoApi
 * @extends {BaseAPI}
 */
export class DemoApi extends BaseAPI {
  /**
   * Generates a new Hedera account with a random private key.
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof DemoApi
   */
  public demoRandomKeyGet(options?: AxiosRequestConfig) {
    return DemoApiFp(this.configuration)
      .demoRandomKeyGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all registered user accounts.
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof DemoApi
   */
  public demoRegisteredUsersGet(options?: AxiosRequestConfig) {
    return DemoApiFp(this.configuration)
      .demoRegisteredUsersGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ExternalApi - axios parameter creator
 * @export
 */
export const ExternalApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Sends data from an external source.
     * @summary Sends data from an external source.
     * @param {ExternalData} externalData Object that contains a VC Document.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    externalPost: async (
      externalData: ExternalData,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'externalData' is not null or undefined
      assertParamExists('externalPost', 'externalData', externalData);
      const localVarPath = `/external`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        externalData,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ExternalApi - functional programming interface
 * @export
 */
export const ExternalApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ExternalApiAxiosParamCreator(configuration);
  return {
    /**
     * Sends data from an external source.
     * @summary Sends data from an external source.
     * @param {ExternalData} externalData Object that contains a VC Document.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async externalPost(
      externalData: ExternalData,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.externalPost(
        externalData,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * ExternalApi - factory interface
 * @export
 */
export const ExternalApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ExternalApiFp(configuration);
  return {
    /**
     * Sends data from an external source.
     * @summary Sends data from an external source.
     * @param {ExternalData} externalData Object that contains a VC Document.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    externalPost(
      externalData: ExternalData,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .externalPost(externalData, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ExternalApi - object-oriented interface
 * @export
 * @class ExternalApi
 * @extends {BaseAPI}
 */
export class ExternalApi extends BaseAPI {
  /**
   * Sends data from an external source.
   * @summary Sends data from an external source.
   * @param {ExternalData} externalData Object that contains a VC Document.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExternalApi
   */
  public externalPost(
    externalData: ExternalData,
    options?: AxiosRequestConfig,
  ) {
    return ExternalApiFp(this.configuration)
      .externalPost(externalData, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * IpfsApi - axios parameter creator
 * @export
 */
export const IpfsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Add file to ipfs.
     * @summary Add file to ipfs.
     * @param {any} body Data array of file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ipfsFilePost: async (
      body: any,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('ipfsFilePost', 'body', body);
      const localVarPath = `/ipfs/file`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'binary/octet-stream';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * IpfsApi - functional programming interface
 * @export
 */
export const IpfsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = IpfsApiAxiosParamCreator(configuration);
  return {
    /**
     * Add file to ipfs.
     * @summary Add file to ipfs.
     * @param {any} body Data array of file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ipfsFilePost(
      body: any,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ipfsFilePost(
        body,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * IpfsApi - factory interface
 * @export
 */
export const IpfsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = IpfsApiFp(configuration);
  return {
    /**
     * Add file to ipfs.
     * @summary Add file to ipfs.
     * @param {any} body Data array of file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ipfsFilePost(body: any, options?: any): AxiosPromise<string> {
      return localVarFp
        .ipfsFilePost(body, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * IpfsApi - object-oriented interface
 * @export
 * @class IpfsApi
 * @extends {BaseAPI}
 */
export class IpfsApi extends BaseAPI {
  /**
   * Add file to ipfs.
   * @summary Add file to ipfs.
   * @param {any} body Data array of file.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IpfsApi
   */
  public ipfsFilePost(body: any, options?: AxiosRequestConfig) {
    return IpfsApiFp(this.configuration)
      .ipfsFilePost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LogsApi - axios parameter creator
 * @export
 */
export const LogsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns logs attributes. For users with the Root Authority role only.
     * @summary Returns logs attributes.
     * @param {string} [name] Part of name.
     * @param {Array<string>} [existingAttributes] Attributes to exclude.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsAttributesGet: async (
      name?: string,
      existingAttributes?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/logs/attributes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (name !== undefined) {
        localVarQueryParameter['name'] = name;
      }

      if (existingAttributes) {
        localVarQueryParameter['existingAttributes'] = existingAttributes;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns logs. For users with the Root Authority role only.
     * @summary Returns logs.
     * @param {LogFilters} [logFilters] Log filters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsPost: async (
      logFilters?: LogFilters,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/logs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        logFilters,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LogsApi - functional programming interface
 * @export
 */
export const LogsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LogsApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns logs attributes. For users with the Root Authority role only.
     * @summary Returns logs attributes.
     * @param {string} [name] Part of name.
     * @param {Array<string>} [existingAttributes] Attributes to exclude.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logsAttributesGet(
      name?: string,
      existingAttributes?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.logsAttributesGet(
          name,
          existingAttributes,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns logs. For users with the Root Authority role only.
     * @summary Returns logs.
     * @param {LogFilters} [logFilters] Log filters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logsPost(
      logFilters?: LogFilters,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse2001>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logsPost(
        logFilters,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * LogsApi - factory interface
 * @export
 */
export const LogsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = LogsApiFp(configuration);
  return {
    /**
     * Returns logs attributes. For users with the Root Authority role only.
     * @summary Returns logs attributes.
     * @param {string} [name] Part of name.
     * @param {Array<string>} [existingAttributes] Attributes to exclude.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsAttributesGet(
      name?: string,
      existingAttributes?: Array<string>,
      options?: any,
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .logsAttributesGet(name, existingAttributes, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns logs. For users with the Root Authority role only.
     * @summary Returns logs.
     * @param {LogFilters} [logFilters] Log filters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logsPost(
      logFilters?: LogFilters,
      options?: any,
    ): AxiosPromise<InlineResponse2001> {
      return localVarFp
        .logsPost(logFilters, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LogsApi - object-oriented interface
 * @export
 * @class LogsApi
 * @extends {BaseAPI}
 */
export class LogsApi extends BaseAPI {
  /**
   * Returns logs attributes. For users with the Root Authority role only.
   * @summary Returns logs attributes.
   * @param {string} [name] Part of name.
   * @param {Array<string>} [existingAttributes] Attributes to exclude.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LogsApi
   */
  public logsAttributesGet(
    name?: string,
    existingAttributes?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return LogsApiFp(this.configuration)
      .logsAttributesGet(name, existingAttributes, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns logs. For users with the Root Authority role only.
   * @summary Returns logs.
   * @param {LogFilters} [logFilters] Log filters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LogsApi
   */
  public logsPost(logFilters?: LogFilters, options?: AxiosRequestConfig) {
    return LogsApiFp(this.configuration)
      .logsPost(logFilters, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PoliciesApi - axios parameter creator
 * @export
 */
export const PoliciesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns all policies. Only users with the Root Authority and Installer role are allowed to make the request.
     * @summary Return a list of all policies.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesGet: async (
      pageIndex?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/policies`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (pageIndex !== undefined) {
        localVarQueryParameter['pageIndex'] = pageIndex;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Imports new policy and all associated artifacts, such as schemas and VCs, from the provided zip file into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Imports new policy from a zip file.
     * @param {any} body A zip file that contains the policy and associated schemas and VCs to be imported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesImportFilePost: async (
      body: any,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('policiesImportFilePost', 'body', body);
      const localVarPath = `/policies/import/file`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'binary/octet-stream';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Previews the policy from a zip file without loading it into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Policy preview from a zip file.
     * @param {any} body A zip file that contains the policy and associated schemas and VCs to be viewed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesImportFilePreviewPost: async (
      body: any,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('policiesImportFilePreviewPost', 'body', body);
      const localVarPath = `/policies/import/file/preview`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'binary/octet-stream';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Imports new policy and all associated artifacts from IPFS into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Imports new policy from IPFS.
     * @param {InlineObject5} inlineObject5
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesImportMessagePost: async (
      inlineObject5: InlineObject5,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'inlineObject5' is not null or undefined
      assertParamExists(
        'policiesImportMessagePost',
        'inlineObject5',
        inlineObject5,
      );
      const localVarPath = `/policies/import/message`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject5,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Previews the policy from IPFS without loading it into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Policy preview from IPFS.
     * @param {InlineObject6} inlineObject6
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesImportMessagePreviewPost: async (
      inlineObject6: InlineObject6,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'inlineObject6' is not null or undefined
      assertParamExists(
        'policiesImportMessagePreviewPost',
        'inlineObject6',
        inlineObject6,
      );
      const localVarPath = `/policies/import/message/preview`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject6,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns data from the root policy block. Only users with the Root Authority and Installer role are allowed to make the request.
     * @summary Retrieves data for the policy root block.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdBlocksGet: async (
      policyId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists('policiesPolicyIdBlocksGet', 'policyId', policyId);
      const localVarPath = `/policies/{policyId}/blocks`.replace(
        `{${'policyId'}}`,
        encodeURIComponent(String(policyId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Requests block data. Only users with a role that described in block are allowed to make the request.
     * @summary Requests block data.
     * @param {string} policyId Selected policy ID.
     * @param {string} uuid Selected block UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdBlocksUuidGet: async (
      policyId: string,
      uuid: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists('policiesPolicyIdBlocksUuidGet', 'policyId', policyId);
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('policiesPolicyIdBlocksUuidGet', 'uuid', uuid);
      const localVarPath = `/policies/{policyId}/blocks/{uuid}`
        .replace(`{${'policyId'}}`, encodeURIComponent(String(policyId)))
        .replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Sends data to the specified block.
     * @summary Sends data to the specified block.
     * @param {string} policyId Selected policy ID.
     * @param {string} uuid Selected block UUID.
     * @param {object} body Object with the data to be sent to the block.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdBlocksUuidPost: async (
      policyId: string,
      uuid: string,
      body: object,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists('policiesPolicyIdBlocksUuidPost', 'policyId', policyId);
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('policiesPolicyIdBlocksUuidPost', 'uuid', uuid);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('policiesPolicyIdBlocksUuidPost', 'body', body);
      const localVarPath = `/policies/{policyId}/blocks/{uuid}`
        .replace(`{${'policyId'}}`, encodeURIComponent(String(policyId)))
        .replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a zip file containing the published policy and all associated artifacts, i.e. schemas and VCs. Only users with the Root Authority role are allowed to make the request.
     * @summary Return policy and its artifacts in a zip file format for the specified policy.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdExportFileGet: async (
      policyId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists('policiesPolicyIdExportFileGet', 'policyId', policyId);
      const localVarPath = `/policies/{policyId}/export/file`.replace(
        `{${'policyId'}}`,
        encodeURIComponent(String(policyId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the Hedera message ID for the specified policy published onto IPFS. Only users with the Root Authority role are allowed to make the request.
     * @summary Return Heder message ID for the specified published policy.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdExportMessageGet: async (
      policyId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists(
        'policiesPolicyIdExportMessageGet',
        'policyId',
        policyId,
      );
      const localVarPath = `/policies/{policyId}/export/message`.replace(
        `{${'policyId'}}`,
        encodeURIComponent(String(policyId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves policy configuration for the specified policy ID. Only users with the Root Authority role are allowed to make the request.
     * @summary Retrieves policy configuration.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdGet: async (
      policyId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists('policiesPolicyIdGet', 'policyId', policyId);
      const localVarPath = `/policies/{policyId}`.replace(
        `{${'policyId'}}`,
        encodeURIComponent(String(policyId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Publishes the policy with the specified (internal) policy ID onto IPFS, sends a message featuring its IPFS CID into the corresponding Hedera topic. Only users with the Root Authority role are allowed to make the request.
     * @summary Publishes the policy onto IPFS.
     * @param {string} policyId Selected policy ID.
     * @param {InlineObject4} inlineObject4
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdPublishPut: async (
      policyId: string,
      inlineObject4: InlineObject4,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists('policiesPolicyIdPublishPut', 'policyId', policyId);
      // verify required parameter 'inlineObject4' is not null or undefined
      assertParamExists(
        'policiesPolicyIdPublishPut',
        'inlineObject4',
        inlineObject4,
      );
      const localVarPath = `/policies/{policyId}/publish`.replace(
        `{${'policyId'}}`,
        encodeURIComponent(String(policyId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject4,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates policy configuration for the specified policy ID. Only users with the Root Authority role are allowed to make the request.
     * @summary Updates policy configuration.
     * @param {string} policyId Selected policy ID.
     * @param {PolicyConfig} policyConfig Object that contains policy configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdPut: async (
      policyId: string,
      policyConfig: PolicyConfig,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists('policiesPolicyIdPut', 'policyId', policyId);
      // verify required parameter 'policyConfig' is not null or undefined
      assertParamExists('policiesPolicyIdPut', 'policyConfig', policyConfig);
      const localVarPath = `/policies/{policyId}`.replace(
        `{${'policyId'}}`,
        encodeURIComponent(String(policyId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        policyConfig,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Requests block ID from a policy by tag. Only users with the Root Authority and Installer roles are allowed to make the request.
     * @summary Requests block ID from a policy by tag.
     * @param {string} policyId Selected policy ID.
     * @param {string} tag Tag from the selected policy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdTagTagGet: async (
      policyId: string,
      tag: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyId' is not null or undefined
      assertParamExists('policiesPolicyIdTagTagGet', 'policyId', policyId);
      // verify required parameter 'tag' is not null or undefined
      assertParamExists('policiesPolicyIdTagTagGet', 'tag', tag);
      const localVarPath = `/policies/{policyId}/tag/{tag}`
        .replace(`{${'policyId'}}`, encodeURIComponent(String(policyId)))
        .replace(`{${'tag'}}`, encodeURIComponent(String(tag)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new policy. Only users with the Root Authority role are allowed to make the request.
     * @summary Creates a new policy.
     * @param {PolicyConfig} policyConfig Object that contains policy configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPost: async (
      policyConfig: PolicyConfig,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyConfig' is not null or undefined
      assertParamExists('policiesPost', 'policyConfig', policyConfig);
      const localVarPath = `/policies`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        policyConfig,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Validates selected policy. Only users with the Root Authority role are allowed to make the request.
     * @summary Validates policy.
     * @param {PolicyConfig} policyConfig Object that contains policy configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesValidatePost: async (
      policyConfig: PolicyConfig,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'policyConfig' is not null or undefined
      assertParamExists('policiesValidatePost', 'policyConfig', policyConfig);
      const localVarPath = `/policies/validate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        policyConfig,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PoliciesApi - functional programming interface
 * @export
 */
export const PoliciesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PoliciesApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns all policies. Only users with the Root Authority and Installer role are allowed to make the request.
     * @summary Return a list of all policies.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesGet(
      pageIndex?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<PolicyConfig & object>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.policiesGet(
        pageIndex,
        pageSize,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Imports new policy and all associated artifacts, such as schemas and VCs, from the provided zip file into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Imports new policy from a zip file.
     * @param {any} body A zip file that contains the policy and associated schemas and VCs to be imported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesImportFilePost(
      body: any,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<PolicyConfig>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesImportFilePost(body, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Previews the policy from a zip file without loading it into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Policy preview from a zip file.
     * @param {any} body A zip file that contains the policy and associated schemas and VCs to be viewed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesImportFilePreviewPost(
      body: any,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PreviewPolicy>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesImportFilePreviewPost(
          body,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Imports new policy and all associated artifacts from IPFS into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Imports new policy from IPFS.
     * @param {InlineObject5} inlineObject5
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesImportMessagePost(
      inlineObject5: InlineObject5,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<PolicyConfig>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesImportMessagePost(
          inlineObject5,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Previews the policy from IPFS without loading it into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Policy preview from IPFS.
     * @param {InlineObject6} inlineObject6
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesImportMessagePreviewPost(
      inlineObject6: InlineObject6,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PreviewPolicy>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesImportMessagePreviewPost(
          inlineObject6,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns data from the root policy block. Only users with the Root Authority and Installer role are allowed to make the request.
     * @summary Retrieves data for the policy root block.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdBlocksGet(
      policyId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyBlock>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdBlocksGet(
          policyId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Requests block data. Only users with a role that described in block are allowed to make the request.
     * @summary Requests block data.
     * @param {string} policyId Selected policy ID.
     * @param {string} uuid Selected block UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdBlocksUuidGet(
      policyId: string,
      uuid: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PolicyBlockData>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdBlocksUuidGet(
          policyId,
          uuid,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Sends data to the specified block.
     * @summary Sends data to the specified block.
     * @param {string} policyId Selected policy ID.
     * @param {string} uuid Selected block UUID.
     * @param {object} body Object with the data to be sent to the block.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdBlocksUuidPost(
      policyId: string,
      uuid: string,
      body: object,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdBlocksUuidPost(
          policyId,
          uuid,
          body,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns a zip file containing the published policy and all associated artifacts, i.e. schemas and VCs. Only users with the Root Authority role are allowed to make the request.
     * @summary Return policy and its artifacts in a zip file format for the specified policy.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdExportFileGet(
      policyId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportPolicy>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdExportFileGet(
          policyId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns the Hedera message ID for the specified policy published onto IPFS. Only users with the Root Authority role are allowed to make the request.
     * @summary Return Heder message ID for the specified published policy.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdExportMessageGet(
      policyId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportPolicy>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdExportMessageGet(
          policyId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Retrieves policy configuration for the specified policy ID. Only users with the Root Authority role are allowed to make the request.
     * @summary Retrieves policy configuration.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdGet(
      policyId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PolicyConfig & object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdGet(policyId, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Publishes the policy with the specified (internal) policy ID onto IPFS, sends a message featuring its IPFS CID into the corresponding Hedera topic. Only users with the Root Authority role are allowed to make the request.
     * @summary Publishes the policy onto IPFS.
     * @param {string} policyId Selected policy ID.
     * @param {InlineObject4} inlineObject4
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdPublishPut(
      policyId: string,
      inlineObject4: InlineObject4,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublishPolicy>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdPublishPut(
          policyId,
          inlineObject4,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Updates policy configuration for the specified policy ID. Only users with the Root Authority role are allowed to make the request.
     * @summary Updates policy configuration.
     * @param {string} policyId Selected policy ID.
     * @param {PolicyConfig} policyConfig Object that contains policy configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdPut(
      policyId: string,
      policyConfig: PolicyConfig,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyConfig>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdPut(
          policyId,
          policyConfig,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Requests block ID from a policy by tag. Only users with the Root Authority and Installer roles are allowed to make the request.
     * @summary Requests block ID from a policy by tag.
     * @param {string} policyId Selected policy ID.
     * @param {string} tag Tag from the selected policy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPolicyIdTagTagGet(
      policyId: string,
      tag: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse200>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesPolicyIdTagTagGet(
          policyId,
          tag,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Creates a new policy. Only users with the Root Authority role are allowed to make the request.
     * @summary Creates a new policy.
     * @param {PolicyConfig} policyConfig Object that contains policy configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesPost(
      policyConfig: PolicyConfig,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPost(
        policyConfig,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Validates selected policy. Only users with the Root Authority role are allowed to make the request.
     * @summary Validates policy.
     * @param {PolicyConfig} policyConfig Object that contains policy configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async policiesValidatePost(
      policyConfig: PolicyConfig,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidatePolicy>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.policiesValidatePost(
          policyConfig,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * PoliciesApi - factory interface
 * @export
 */
export const PoliciesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PoliciesApiFp(configuration);
  return {
    /**
     * Returns all policies. Only users with the Root Authority and Installer role are allowed to make the request.
     * @summary Return a list of all policies.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesGet(
      pageIndex?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<Array<PolicyConfig & object>> {
      return localVarFp
        .policiesGet(pageIndex, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Imports new policy and all associated artifacts, such as schemas and VCs, from the provided zip file into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Imports new policy from a zip file.
     * @param {any} body A zip file that contains the policy and associated schemas and VCs to be imported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesImportFilePost(
      body: any,
      options?: any,
    ): AxiosPromise<Array<PolicyConfig>> {
      return localVarFp
        .policiesImportFilePost(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Previews the policy from a zip file without loading it into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Policy preview from a zip file.
     * @param {any} body A zip file that contains the policy and associated schemas and VCs to be viewed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesImportFilePreviewPost(
      body: any,
      options?: any,
    ): AxiosPromise<PreviewPolicy> {
      return localVarFp
        .policiesImportFilePreviewPost(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Imports new policy and all associated artifacts from IPFS into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Imports new policy from IPFS.
     * @param {InlineObject5} inlineObject5
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesImportMessagePost(
      inlineObject5: InlineObject5,
      options?: any,
    ): AxiosPromise<Array<PolicyConfig>> {
      return localVarFp
        .policiesImportMessagePost(inlineObject5, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Previews the policy from IPFS without loading it into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Policy preview from IPFS.
     * @param {InlineObject6} inlineObject6
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesImportMessagePreviewPost(
      inlineObject6: InlineObject6,
      options?: any,
    ): AxiosPromise<PreviewPolicy> {
      return localVarFp
        .policiesImportMessagePreviewPost(inlineObject6, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns data from the root policy block. Only users with the Root Authority and Installer role are allowed to make the request.
     * @summary Retrieves data for the policy root block.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdBlocksGet(
      policyId: string,
      options?: any,
    ): AxiosPromise<PolicyBlock> {
      return localVarFp
        .policiesPolicyIdBlocksGet(policyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Requests block data. Only users with a role that described in block are allowed to make the request.
     * @summary Requests block data.
     * @param {string} policyId Selected policy ID.
     * @param {string} uuid Selected block UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdBlocksUuidGet(
      policyId: string,
      uuid: string,
      options?: any,
    ): AxiosPromise<PolicyBlockData> {
      return localVarFp
        .policiesPolicyIdBlocksUuidGet(policyId, uuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Sends data to the specified block.
     * @summary Sends data to the specified block.
     * @param {string} policyId Selected policy ID.
     * @param {string} uuid Selected block UUID.
     * @param {object} body Object with the data to be sent to the block.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdBlocksUuidPost(
      policyId: string,
      uuid: string,
      body: object,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .policiesPolicyIdBlocksUuidPost(policyId, uuid, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a zip file containing the published policy and all associated artifacts, i.e. schemas and VCs. Only users with the Root Authority role are allowed to make the request.
     * @summary Return policy and its artifacts in a zip file format for the specified policy.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdExportFileGet(
      policyId: string,
      options?: any,
    ): AxiosPromise<ExportPolicy> {
      return localVarFp
        .policiesPolicyIdExportFileGet(policyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns the Hedera message ID for the specified policy published onto IPFS. Only users with the Root Authority role are allowed to make the request.
     * @summary Return Heder message ID for the specified published policy.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdExportMessageGet(
      policyId: string,
      options?: any,
    ): AxiosPromise<ExportPolicy> {
      return localVarFp
        .policiesPolicyIdExportMessageGet(policyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves policy configuration for the specified policy ID. Only users with the Root Authority role are allowed to make the request.
     * @summary Retrieves policy configuration.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdGet(
      policyId: string,
      options?: any,
    ): AxiosPromise<PolicyConfig & object> {
      return localVarFp
        .policiesPolicyIdGet(policyId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Publishes the policy with the specified (internal) policy ID onto IPFS, sends a message featuring its IPFS CID into the corresponding Hedera topic. Only users with the Root Authority role are allowed to make the request.
     * @summary Publishes the policy onto IPFS.
     * @param {string} policyId Selected policy ID.
     * @param {InlineObject4} inlineObject4
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdPublishPut(
      policyId: string,
      inlineObject4: InlineObject4,
      options?: any,
    ): AxiosPromise<PublishPolicy> {
      return localVarFp
        .policiesPolicyIdPublishPut(policyId, inlineObject4, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates policy configuration for the specified policy ID. Only users with the Root Authority role are allowed to make the request.
     * @summary Updates policy configuration.
     * @param {string} policyId Selected policy ID.
     * @param {PolicyConfig} policyConfig Object that contains policy configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdPut(
      policyId: string,
      policyConfig: PolicyConfig,
      options?: any,
    ): AxiosPromise<PolicyConfig> {
      return localVarFp
        .policiesPolicyIdPut(policyId, policyConfig, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Requests block ID from a policy by tag. Only users with the Root Authority and Installer roles are allowed to make the request.
     * @summary Requests block ID from a policy by tag.
     * @param {string} policyId Selected policy ID.
     * @param {string} tag Tag from the selected policy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPolicyIdTagTagGet(
      policyId: string,
      tag: string,
      options?: any,
    ): AxiosPromise<InlineResponse200> {
      return localVarFp
        .policiesPolicyIdTagTagGet(policyId, tag, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a new policy. Only users with the Root Authority role are allowed to make the request.
     * @summary Creates a new policy.
     * @param {PolicyConfig} policyConfig Object that contains policy configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesPost(
      policyConfig: PolicyConfig,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .policiesPost(policyConfig, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Validates selected policy. Only users with the Root Authority role are allowed to make the request.
     * @summary Validates policy.
     * @param {PolicyConfig} policyConfig Object that contains policy configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    policiesValidatePost(
      policyConfig: PolicyConfig,
      options?: any,
    ): AxiosPromise<ValidatePolicy> {
      return localVarFp
        .policiesValidatePost(policyConfig, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PoliciesApi - object-oriented interface
 * @export
 * @class PoliciesApi
 * @extends {BaseAPI}
 */
export class PoliciesApi extends BaseAPI {
  /**
   * Returns all policies. Only users with the Root Authority and Installer role are allowed to make the request.
   * @summary Return a list of all policies.
   * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
   * @param {number} [pageSize] The numbers of items to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesGet(
    pageIndex?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesGet(pageIndex, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Imports new policy and all associated artifacts, such as schemas and VCs, from the provided zip file into the local DB. Only users with the Root Authority role are allowed to make the request.
   * @summary Imports new policy from a zip file.
   * @param {any} body A zip file that contains the policy and associated schemas and VCs to be imported.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesImportFilePost(body: any, options?: AxiosRequestConfig) {
    return PoliciesApiFp(this.configuration)
      .policiesImportFilePost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Previews the policy from a zip file without loading it into the local DB. Only users with the Root Authority role are allowed to make the request.
   * @summary Policy preview from a zip file.
   * @param {any} body A zip file that contains the policy and associated schemas and VCs to be viewed.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesImportFilePreviewPost(
    body: any,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesImportFilePreviewPost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Imports new policy and all associated artifacts from IPFS into the local DB. Only users with the Root Authority role are allowed to make the request.
   * @summary Imports new policy from IPFS.
   * @param {InlineObject5} inlineObject5
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesImportMessagePost(
    inlineObject5: InlineObject5,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesImportMessagePost(inlineObject5, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Previews the policy from IPFS without loading it into the local DB. Only users with the Root Authority role are allowed to make the request.
   * @summary Policy preview from IPFS.
   * @param {InlineObject6} inlineObject6
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesImportMessagePreviewPost(
    inlineObject6: InlineObject6,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesImportMessagePreviewPost(inlineObject6, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns data from the root policy block. Only users with the Root Authority and Installer role are allowed to make the request.
   * @summary Retrieves data for the policy root block.
   * @param {string} policyId Selected policy ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdBlocksGet(
    policyId: string,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdBlocksGet(policyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Requests block data. Only users with a role that described in block are allowed to make the request.
   * @summary Requests block data.
   * @param {string} policyId Selected policy ID.
   * @param {string} uuid Selected block UUID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdBlocksUuidGet(
    policyId: string,
    uuid: string,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdBlocksUuidGet(policyId, uuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Sends data to the specified block.
   * @summary Sends data to the specified block.
   * @param {string} policyId Selected policy ID.
   * @param {string} uuid Selected block UUID.
   * @param {object} body Object with the data to be sent to the block.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdBlocksUuidPost(
    policyId: string,
    uuid: string,
    body: object,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdBlocksUuidPost(policyId, uuid, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a zip file containing the published policy and all associated artifacts, i.e. schemas and VCs. Only users with the Root Authority role are allowed to make the request.
   * @summary Return policy and its artifacts in a zip file format for the specified policy.
   * @param {string} policyId Selected policy ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdExportFileGet(
    policyId: string,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdExportFileGet(policyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the Hedera message ID for the specified policy published onto IPFS. Only users with the Root Authority role are allowed to make the request.
   * @summary Return Heder message ID for the specified published policy.
   * @param {string} policyId Selected policy ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdExportMessageGet(
    policyId: string,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdExportMessageGet(policyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves policy configuration for the specified policy ID. Only users with the Root Authority role are allowed to make the request.
   * @summary Retrieves policy configuration.
   * @param {string} policyId Selected policy ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdGet(policyId: string, options?: AxiosRequestConfig) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdGet(policyId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Publishes the policy with the specified (internal) policy ID onto IPFS, sends a message featuring its IPFS CID into the corresponding Hedera topic. Only users with the Root Authority role are allowed to make the request.
   * @summary Publishes the policy onto IPFS.
   * @param {string} policyId Selected policy ID.
   * @param {InlineObject4} inlineObject4
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdPublishPut(
    policyId: string,
    inlineObject4: InlineObject4,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdPublishPut(policyId, inlineObject4, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Updates policy configuration for the specified policy ID. Only users with the Root Authority role are allowed to make the request.
   * @summary Updates policy configuration.
   * @param {string} policyId Selected policy ID.
   * @param {PolicyConfig} policyConfig Object that contains policy configuration.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdPut(
    policyId: string,
    policyConfig: PolicyConfig,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdPut(policyId, policyConfig, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Requests block ID from a policy by tag. Only users with the Root Authority and Installer roles are allowed to make the request.
   * @summary Requests block ID from a policy by tag.
   * @param {string} policyId Selected policy ID.
   * @param {string} tag Tag from the selected policy.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPolicyIdTagTagGet(
    policyId: string,
    tag: string,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPolicyIdTagTagGet(policyId, tag, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new policy. Only users with the Root Authority role are allowed to make the request.
   * @summary Creates a new policy.
   * @param {PolicyConfig} policyConfig Object that contains policy configuration.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesPost(
    policyConfig: PolicyConfig,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesPost(policyConfig, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Validates selected policy. Only users with the Root Authority role are allowed to make the request.
   * @summary Validates policy.
   * @param {PolicyConfig} policyConfig Object that contains policy configuration.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public policiesValidatePost(
    policyConfig: PolicyConfig,
    options?: AxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .policiesValidatePost(policyConfig, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ProfilesApi - axios parameter creator
 * @export
 */
export const ProfilesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Requests Hedera account balance. Only users with the Installer role are allowed to make the request.
     * @summary Returns user\'s Hedera account balance.
     * @param {string} username The name of the user for whom to fetch the balance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profilesUsernameBalanceGet: async (
      username: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('profilesUsernameBalanceGet', 'username', username);
      const localVarPath = `/profiles/{username}/balance`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns user account information. For users with the Root Authority role it also returns address book and VC document information.
     * @summary Returns user account info.
     * @param {string} username The name of the user for whom to fetch the information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profilesUsernameGet: async (
      username: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('profilesUsernameGet', 'username', username);
      const localVarPath = `/profiles/{username}`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Sets Hedera credentials for the user. For users with the Root Authority role it also creates an address book.
     * @summary Sets Hedera credentials for the user.
     * @param {string} username The name of the user for whom to update the information.
     * @param {User} user Object that contains the Hedera account data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profilesUsernamePut: async (
      username: string,
      user: User,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('profilesUsernamePut', 'username', username);
      // verify required parameter 'user' is not null or undefined
      assertParamExists('profilesUsernamePut', 'user', user);
      const localVarPath = `/profiles/{username}`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        user,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProfilesApi - functional programming interface
 * @export
 */
export const ProfilesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ProfilesApiAxiosParamCreator(configuration);
  return {
    /**
     * Requests Hedera account balance. Only users with the Installer role are allowed to make the request.
     * @summary Returns user\'s Hedera account balance.
     * @param {string} username The name of the user for whom to fetch the balance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async profilesUsernameBalanceGet(
      username: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.profilesUsernameBalanceGet(
          username,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns user account information. For users with the Root Authority role it also returns address book and VC document information.
     * @summary Returns user account info.
     * @param {string} username The name of the user for whom to fetch the information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async profilesUsernameGet(
      username: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.profilesUsernameGet(username, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Sets Hedera credentials for the user. For users with the Root Authority role it also creates an address book.
     * @summary Sets Hedera credentials for the user.
     * @param {string} username The name of the user for whom to update the information.
     * @param {User} user Object that contains the Hedera account data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async profilesUsernamePut(
      username: string,
      user: User,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.profilesUsernamePut(
          username,
          user,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * ProfilesApi - factory interface
 * @export
 */
export const ProfilesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ProfilesApiFp(configuration);
  return {
    /**
     * Requests Hedera account balance. Only users with the Installer role are allowed to make the request.
     * @summary Returns user\'s Hedera account balance.
     * @param {string} username The name of the user for whom to fetch the balance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profilesUsernameBalanceGet(
      username: string,
      options?: any,
    ): AxiosPromise<string> {
      return localVarFp
        .profilesUsernameBalanceGet(username, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns user account information. For users with the Root Authority role it also returns address book and VC document information.
     * @summary Returns user account info.
     * @param {string} username The name of the user for whom to fetch the information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profilesUsernameGet(username: string, options?: any): AxiosPromise<User> {
      return localVarFp
        .profilesUsernameGet(username, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Sets Hedera credentials for the user. For users with the Root Authority role it also creates an address book.
     * @summary Sets Hedera credentials for the user.
     * @param {string} username The name of the user for whom to update the information.
     * @param {User} user Object that contains the Hedera account data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profilesUsernamePut(
      username: string,
      user: User,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .profilesUsernamePut(username, user, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ProfilesApi - object-oriented interface
 * @export
 * @class ProfilesApi
 * @extends {BaseAPI}
 */
export class ProfilesApi extends BaseAPI {
  /**
   * Requests Hedera account balance. Only users with the Installer role are allowed to make the request.
   * @summary Returns user\'s Hedera account balance.
   * @param {string} username The name of the user for whom to fetch the balance.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfilesApi
   */
  public profilesUsernameBalanceGet(
    username: string,
    options?: AxiosRequestConfig,
  ) {
    return ProfilesApiFp(this.configuration)
      .profilesUsernameBalanceGet(username, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns user account information. For users with the Root Authority role it also returns address book and VC document information.
   * @summary Returns user account info.
   * @param {string} username The name of the user for whom to fetch the information.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfilesApi
   */
  public profilesUsernameGet(username: string, options?: AxiosRequestConfig) {
    return ProfilesApiFp(this.configuration)
      .profilesUsernameGet(username, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Sets Hedera credentials for the user. For users with the Root Authority role it also creates an address book.
   * @summary Sets Hedera credentials for the user.
   * @param {string} username The name of the user for whom to update the information.
   * @param {User} user Object that contains the Hedera account data.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfilesApi
   */
  public profilesUsernamePut(
    username: string,
    user: User,
    options?: AxiosRequestConfig,
  ) {
    return ProfilesApiFp(this.configuration)
      .profilesUsernamePut(username, user, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SchemasApi - axios parameter creator
 * @export
 */
export const SchemasApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns all schemas.
     * @summary Returns all schemas.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasGet: async (
      pageIndex?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/schemas`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (pageIndex !== undefined) {
        localVarQueryParameter['pageIndex'] = pageIndex;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Imports new schema from a zip file into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Imports new schema from a zip file.
     * @param {any} body A zip file containing schema to be imported.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    schemasImportFilePost: async (
      body: any,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('schemasImportFilePost', 'body', body);
      const localVarPath = `/schemas/import/file`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'binary/octet-stream';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Previews the schema from a zip file. Only users with the Root Authority role are allowed to make the request.
     * @summary Schema preview from a zip file.
     * @param {any} body A zip file containing the schema to be viewed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasImportFilePreviewPost: async (
      body: any,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('schemasImportFilePreviewPost', 'body', body);
      const localVarPath = `/schemas/import/file/preview`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'binary/octet-stream';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Imports new schema from IPFS into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Imports new schema from IPFS.
     * @param {InlineObject1} inlineObject1
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    schemasImportMessagePost: async (
      inlineObject1: InlineObject1,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'inlineObject1' is not null or undefined
      assertParamExists(
        'schemasImportMessagePost',
        'inlineObject1',
        inlineObject1,
      );
      const localVarPath = `/schemas/import/message`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject1,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Previews the schema from IPFS without loading it into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Schema preview from IPFS.
     * @param {InlineObject3} inlineObject3
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasImportMessagePreviewPost: async (
      inlineObject3: InlineObject3,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'inlineObject3' is not null or undefined
      assertParamExists(
        'schemasImportMessagePreviewPost',
        'inlineObject3',
        inlineObject3,
      );
      const localVarPath = `/schemas/import/message/preview`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject3,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates new schema. Only users with the Root Authority role are allowed to make the request.
     * @summary Create new schema.
     * @param {Schema} schema Object that contains a valid schema.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    schemasPost: async (
      schema: Schema,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'schema' is not null or undefined
      assertParamExists('schemasPost', 'schema', schema);
      const localVarPath = `/schemas`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        schema,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes the schema with the provided schema ID. Only users with the Root Authority role are allowed to make the request.
     * @summary Deletes the schema.
     * @param {string} schemaId Schema ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSchemaIdDelete: async (
      schemaId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'schemaId' is not null or undefined
      assertParamExists('schemasSchemaIdDelete', 'schemaId', schemaId);
      const localVarPath = `/schemas/{schemaId}`.replace(
        `{${'schemaId'}}`,
        encodeURIComponent(String(schemaId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns schema files for the schemas. Only users with the Root Authority role are allowed to make the request.
     * @summary Return zip file with schemas.
     * @param {string} schemaId Selected schema ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSchemaIdExportFilePost: async (
      schemaId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'schemaId' is not null or undefined
      assertParamExists('schemasSchemaIdExportFilePost', 'schemaId', schemaId);
      const localVarPath = `/schemas/{schemaId}/export/file`.replace(
        `{${'schemaId'}}`,
        encodeURIComponent(String(schemaId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns Hedera message IDs of the published schemas, these messages contain IPFS CIDs of these schema files. Only users with the Root Authority role are allowed to make the request.
     * @summary List Hedera message IDs of published schemas.
     * @param {string} schemaId Selected schema ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSchemaIdExportMessagePost: async (
      schemaId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'schemaId' is not null or undefined
      assertParamExists(
        'schemasSchemaIdExportMessagePost',
        'schemaId',
        schemaId,
      );
      const localVarPath = `/schemas/{schemaId}/export/message`.replace(
        `{${'schemaId'}}`,
        encodeURIComponent(String(schemaId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Publishes the schema with the provided (internal) schema ID onto IPFS, sends a message featuring IPFS CID into the corresponding Hedera topic. Only users with the Root Authority role are allowed to make the request.
     * @summary Publishes the schema.
     * @param {string} schemaId Schema ID.
     * @param {InlineObject} inlineObject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSchemaIdPublishPut: async (
      schemaId: string,
      inlineObject: InlineObject,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'schemaId' is not null or undefined
      assertParamExists('schemasSchemaIdPublishPut', 'schemaId', schemaId);
      // verify required parameter 'inlineObject' is not null or undefined
      assertParamExists(
        'schemasSchemaIdPublishPut',
        'inlineObject',
        inlineObject,
      );
      const localVarPath = `/schemas/{schemaId}/publish`.replace(
        `{${'schemaId'}}`,
        encodeURIComponent(String(schemaId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates the schema with the provided schema ID. Only users with the Root Authority role are allowed to make the request.
     * @summary Updates the schema.
     * @param {string} schemaId Schema ID.
     * @param {Schema} schema Object that contains a valid schema.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSchemaIdPut: async (
      schemaId: string,
      schema: Schema,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'schemaId' is not null or undefined
      assertParamExists('schemasSchemaIdPut', 'schemaId', schemaId);
      // verify required parameter 'schema' is not null or undefined
      assertParamExists('schemasSchemaIdPut', 'schema', schema);
      const localVarPath = `/schemas/{schemaId}`.replace(
        `{${'schemaId'}}`,
        encodeURIComponent(String(schemaId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        schema,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns all schemas by topicId.
     * @summary Returns all schemas by topicId.
     * @param {string} topicId Topic ID.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasTopicIdGet: async (
      topicId: string,
      pageIndex?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'topicId' is not null or undefined
      assertParamExists('schemasTopicIdGet', 'topicId', topicId);
      const localVarPath = `/schemas/{topicId}`.replace(
        `{${'topicId'}}`,
        encodeURIComponent(String(topicId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (pageIndex !== undefined) {
        localVarQueryParameter['pageIndex'] = pageIndex;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Imports new schema from a zip file into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Imports new schema from a zip file.
     * @param {string} topicId Topic ID.
     * @param {any} body A zip file containing schema to be imported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasTopicIdImportFilePost: async (
      topicId: string,
      body: any,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'topicId' is not null or undefined
      assertParamExists('schemasTopicIdImportFilePost', 'topicId', topicId);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('schemasTopicIdImportFilePost', 'body', body);
      const localVarPath = `/schemas/{topicId}/import/file`.replace(
        `{${'topicId'}}`,
        encodeURIComponent(String(topicId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'binary/octet-stream';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Imports new schema from IPFS into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Imports new schema from IPFS.
     * @param {string} topicId Topic ID.
     * @param {InlineObject2} inlineObject2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasTopicIdImportMessagePost: async (
      topicId: string,
      inlineObject2: InlineObject2,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'topicId' is not null or undefined
      assertParamExists('schemasTopicIdImportMessagePost', 'topicId', topicId);
      // verify required parameter 'inlineObject2' is not null or undefined
      assertParamExists(
        'schemasTopicIdImportMessagePost',
        'inlineObject2',
        inlineObject2,
      );
      const localVarPath = `/schemas/{topicId}/import/message`.replace(
        `{${'topicId'}}`,
        encodeURIComponent(String(topicId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject2,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates new schema. Only users with the Root Authority role are allowed to make the request.
     * @summary Create new schema.
     * @param {string} topicId Topic ID.
     * @param {Schema} schema Object that contains a valid schema.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasTopicIdPost: async (
      topicId: string,
      schema: Schema,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'topicId' is not null or undefined
      assertParamExists('schemasTopicIdPost', 'topicId', topicId);
      // verify required parameter 'schema' is not null or undefined
      assertParamExists('schemasTopicIdPost', 'schema', schema);
      const localVarPath = `/schemas/{topicId}`.replace(
        `{${'topicId'}}`,
        encodeURIComponent(String(topicId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        schema,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SchemasApi - functional programming interface
 * @export
 */
export const SchemasApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SchemasApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns all schemas.
     * @summary Returns all schemas.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasGet(
      pageIndex?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.schemasGet(
        pageIndex,
        pageSize,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Imports new schema from a zip file into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Imports new schema from a zip file.
     * @param {any} body A zip file containing schema to be imported.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async schemasImportFilePost(
      body: any,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasImportFilePost(body, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Previews the schema from a zip file. Only users with the Root Authority role are allowed to make the request.
     * @summary Schema preview from a zip file.
     * @param {any} body A zip file containing the schema to be viewed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasImportFilePreviewPost(
      body: any,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasImportFilePreviewPost(
          body,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Imports new schema from IPFS into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Imports new schema from IPFS.
     * @param {InlineObject1} inlineObject1
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async schemasImportMessagePost(
      inlineObject1: InlineObject1,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasImportMessagePost(
          inlineObject1,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Previews the schema from IPFS without loading it into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Schema preview from IPFS.
     * @param {InlineObject3} inlineObject3
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasImportMessagePreviewPost(
      inlineObject3: InlineObject3,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasImportMessagePreviewPost(
          inlineObject3,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Creates new schema. Only users with the Root Authority role are allowed to make the request.
     * @summary Create new schema.
     * @param {Schema} schema Object that contains a valid schema.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async schemasPost(
      schema: Schema,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.schemasPost(
        schema,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Deletes the schema with the provided schema ID. Only users with the Root Authority role are allowed to make the request.
     * @summary Deletes the schema.
     * @param {string} schemaId Schema ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasSchemaIdDelete(
      schemaId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasSchemaIdDelete(
          schemaId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns schema files for the schemas. Only users with the Root Authority role are allowed to make the request.
     * @summary Return zip file with schemas.
     * @param {string} schemaId Selected schema ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasSchemaIdExportFilePost(
      schemaId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasSchemaIdExportFilePost(
          schemaId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns Hedera message IDs of the published schemas, these messages contain IPFS CIDs of these schema files. Only users with the Root Authority role are allowed to make the request.
     * @summary List Hedera message IDs of published schemas.
     * @param {string} schemaId Selected schema ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasSchemaIdExportMessagePost(
      schemaId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportSchema>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasSchemaIdExportMessagePost(
          schemaId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Publishes the schema with the provided (internal) schema ID onto IPFS, sends a message featuring IPFS CID into the corresponding Hedera topic. Only users with the Root Authority role are allowed to make the request.
     * @summary Publishes the schema.
     * @param {string} schemaId Schema ID.
     * @param {InlineObject} inlineObject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasSchemaIdPublishPut(
      schemaId: string,
      inlineObject: InlineObject,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasSchemaIdPublishPut(
          schemaId,
          inlineObject,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Updates the schema with the provided schema ID. Only users with the Root Authority role are allowed to make the request.
     * @summary Updates the schema.
     * @param {string} schemaId Schema ID.
     * @param {Schema} schema Object that contains a valid schema.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasSchemaIdPut(
      schemaId: string,
      schema: Schema,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasSchemaIdPut(
          schemaId,
          schema,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns all schemas by topicId.
     * @summary Returns all schemas by topicId.
     * @param {string} topicId Topic ID.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasTopicIdGet(
      topicId: string,
      pageIndex?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasTopicIdGet(
          topicId,
          pageIndex,
          pageSize,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Imports new schema from a zip file into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Imports new schema from a zip file.
     * @param {string} topicId Topic ID.
     * @param {any} body A zip file containing schema to be imported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasTopicIdImportFilePost(
      topicId: string,
      body: any,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasTopicIdImportFilePost(
          topicId,
          body,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Imports new schema from IPFS into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Imports new schema from IPFS.
     * @param {string} topicId Topic ID.
     * @param {InlineObject2} inlineObject2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasTopicIdImportMessagePost(
      topicId: string,
      inlineObject2: InlineObject2,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasTopicIdImportMessagePost(
          topicId,
          inlineObject2,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Creates new schema. Only users with the Root Authority role are allowed to make the request.
     * @summary Create new schema.
     * @param {string} topicId Topic ID.
     * @param {Schema} schema Object that contains a valid schema.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async schemasTopicIdPost(
      topicId: string,
      schema: Schema,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.schemasTopicIdPost(
          topicId,
          schema,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * SchemasApi - factory interface
 * @export
 */
export const SchemasApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SchemasApiFp(configuration);
  return {
    /**
     * Returns all schemas.
     * @summary Returns all schemas.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasGet(
      pageIndex?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<Array<Schema>> {
      return localVarFp
        .schemasGet(pageIndex, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Imports new schema from a zip file into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Imports new schema from a zip file.
     * @param {any} body A zip file containing schema to be imported.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    schemasImportFilePost(
      body: any,
      options?: any,
    ): AxiosPromise<Array<Schema>> {
      return localVarFp
        .schemasImportFilePost(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Previews the schema from a zip file. Only users with the Root Authority role are allowed to make the request.
     * @summary Schema preview from a zip file.
     * @param {any} body A zip file containing the schema to be viewed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasImportFilePreviewPost(
      body: any,
      options?: any,
    ): AxiosPromise<Array<Schema>> {
      return localVarFp
        .schemasImportFilePreviewPost(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Imports new schema from IPFS into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Imports new schema from IPFS.
     * @param {InlineObject1} inlineObject1
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    schemasImportMessagePost(
      inlineObject1: InlineObject1,
      options?: any,
    ): AxiosPromise<Array<Schema>> {
      return localVarFp
        .schemasImportMessagePost(inlineObject1, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Previews the schema from IPFS without loading it into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Schema preview from IPFS.
     * @param {InlineObject3} inlineObject3
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasImportMessagePreviewPost(
      inlineObject3: InlineObject3,
      options?: any,
    ): AxiosPromise<Array<Schema>> {
      return localVarFp
        .schemasImportMessagePreviewPost(inlineObject3, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates new schema. Only users with the Root Authority role are allowed to make the request.
     * @summary Create new schema.
     * @param {Schema} schema Object that contains a valid schema.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    schemasPost(schema: Schema, options?: any): AxiosPromise<void> {
      return localVarFp
        .schemasPost(schema, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes the schema with the provided schema ID. Only users with the Root Authority role are allowed to make the request.
     * @summary Deletes the schema.
     * @param {string} schemaId Schema ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSchemaIdDelete(
      schemaId: string,
      options?: any,
    ): AxiosPromise<Array<Schema>> {
      return localVarFp
        .schemasSchemaIdDelete(schemaId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns schema files for the schemas. Only users with the Root Authority role are allowed to make the request.
     * @summary Return zip file with schemas.
     * @param {string} schemaId Selected schema ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSchemaIdExportFilePost(
      schemaId: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .schemasSchemaIdExportFilePost(schemaId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns Hedera message IDs of the published schemas, these messages contain IPFS CIDs of these schema files. Only users with the Root Authority role are allowed to make the request.
     * @summary List Hedera message IDs of published schemas.
     * @param {string} schemaId Selected schema ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSchemaIdExportMessagePost(
      schemaId: string,
      options?: any,
    ): AxiosPromise<ExportSchema> {
      return localVarFp
        .schemasSchemaIdExportMessagePost(schemaId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Publishes the schema with the provided (internal) schema ID onto IPFS, sends a message featuring IPFS CID into the corresponding Hedera topic. Only users with the Root Authority role are allowed to make the request.
     * @summary Publishes the schema.
     * @param {string} schemaId Schema ID.
     * @param {InlineObject} inlineObject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSchemaIdPublishPut(
      schemaId: string,
      inlineObject: InlineObject,
      options?: any,
    ): AxiosPromise<Array<Schema>> {
      return localVarFp
        .schemasSchemaIdPublishPut(schemaId, inlineObject, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates the schema with the provided schema ID. Only users with the Root Authority role are allowed to make the request.
     * @summary Updates the schema.
     * @param {string} schemaId Schema ID.
     * @param {Schema} schema Object that contains a valid schema.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasSchemaIdPut(
      schemaId: string,
      schema: Schema,
      options?: any,
    ): AxiosPromise<Array<Schema>> {
      return localVarFp
        .schemasSchemaIdPut(schemaId, schema, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns all schemas by topicId.
     * @summary Returns all schemas by topicId.
     * @param {string} topicId Topic ID.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasTopicIdGet(
      topicId: string,
      pageIndex?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<Array<Schema>> {
      return localVarFp
        .schemasTopicIdGet(topicId, pageIndex, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Imports new schema from a zip file into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Imports new schema from a zip file.
     * @param {string} topicId Topic ID.
     * @param {any} body A zip file containing schema to be imported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasTopicIdImportFilePost(
      topicId: string,
      body: any,
      options?: any,
    ): AxiosPromise<Array<Schema>> {
      return localVarFp
        .schemasTopicIdImportFilePost(topicId, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Imports new schema from IPFS into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Imports new schema from IPFS.
     * @param {string} topicId Topic ID.
     * @param {InlineObject2} inlineObject2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasTopicIdImportMessagePost(
      topicId: string,
      inlineObject2: InlineObject2,
      options?: any,
    ): AxiosPromise<Array<Schema>> {
      return localVarFp
        .schemasTopicIdImportMessagePost(topicId, inlineObject2, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates new schema. Only users with the Root Authority role are allowed to make the request.
     * @summary Create new schema.
     * @param {string} topicId Topic ID.
     * @param {Schema} schema Object that contains a valid schema.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    schemasTopicIdPost(
      topicId: string,
      schema: Schema,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .schemasTopicIdPost(topicId, schema, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SchemasApi - object-oriented interface
 * @export
 * @class SchemasApi
 * @extends {BaseAPI}
 */
export class SchemasApi extends BaseAPI {
  /**
   * Returns all schemas.
   * @summary Returns all schemas.
   * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
   * @param {number} [pageSize] The numbers of items to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasGet(
    pageIndex?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasGet(pageIndex, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Imports new schema from a zip file into the local DB. Only users with the Root Authority role are allowed to make the request.
   * @summary Imports new schema from a zip file.
   * @param {any} body A zip file containing schema to be imported.
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasImportFilePost(body: any, options?: AxiosRequestConfig) {
    return SchemasApiFp(this.configuration)
      .schemasImportFilePost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Previews the schema from a zip file. Only users with the Root Authority role are allowed to make the request.
   * @summary Schema preview from a zip file.
   * @param {any} body A zip file containing the schema to be viewed.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasImportFilePreviewPost(body: any, options?: AxiosRequestConfig) {
    return SchemasApiFp(this.configuration)
      .schemasImportFilePreviewPost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Imports new schema from IPFS into the local DB. Only users with the Root Authority role are allowed to make the request.
   * @summary Imports new schema from IPFS.
   * @param {InlineObject1} inlineObject1
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasImportMessagePost(
    inlineObject1: InlineObject1,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasImportMessagePost(inlineObject1, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Previews the schema from IPFS without loading it into the local DB. Only users with the Root Authority role are allowed to make the request.
   * @summary Schema preview from IPFS.
   * @param {InlineObject3} inlineObject3
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasImportMessagePreviewPost(
    inlineObject3: InlineObject3,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasImportMessagePreviewPost(inlineObject3, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates new schema. Only users with the Root Authority role are allowed to make the request.
   * @summary Create new schema.
   * @param {Schema} schema Object that contains a valid schema.
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasPost(schema: Schema, options?: AxiosRequestConfig) {
    return SchemasApiFp(this.configuration)
      .schemasPost(schema, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes the schema with the provided schema ID. Only users with the Root Authority role are allowed to make the request.
   * @summary Deletes the schema.
   * @param {string} schemaId Schema ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasSchemaIdDelete(schemaId: string, options?: AxiosRequestConfig) {
    return SchemasApiFp(this.configuration)
      .schemasSchemaIdDelete(schemaId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns schema files for the schemas. Only users with the Root Authority role are allowed to make the request.
   * @summary Return zip file with schemas.
   * @param {string} schemaId Selected schema ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasSchemaIdExportFilePost(
    schemaId: string,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasSchemaIdExportFilePost(schemaId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns Hedera message IDs of the published schemas, these messages contain IPFS CIDs of these schema files. Only users with the Root Authority role are allowed to make the request.
   * @summary List Hedera message IDs of published schemas.
   * @param {string} schemaId Selected schema ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasSchemaIdExportMessagePost(
    schemaId: string,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasSchemaIdExportMessagePost(schemaId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Publishes the schema with the provided (internal) schema ID onto IPFS, sends a message featuring IPFS CID into the corresponding Hedera topic. Only users with the Root Authority role are allowed to make the request.
   * @summary Publishes the schema.
   * @param {string} schemaId Schema ID.
   * @param {InlineObject} inlineObject
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasSchemaIdPublishPut(
    schemaId: string,
    inlineObject: InlineObject,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasSchemaIdPublishPut(schemaId, inlineObject, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Updates the schema with the provided schema ID. Only users with the Root Authority role are allowed to make the request.
   * @summary Updates the schema.
   * @param {string} schemaId Schema ID.
   * @param {Schema} schema Object that contains a valid schema.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasSchemaIdPut(
    schemaId: string,
    schema: Schema,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasSchemaIdPut(schemaId, schema, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns all schemas by topicId.
   * @summary Returns all schemas by topicId.
   * @param {string} topicId Topic ID.
   * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
   * @param {number} [pageSize] The numbers of items to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasTopicIdGet(
    topicId: string,
    pageIndex?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasTopicIdGet(topicId, pageIndex, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Imports new schema from a zip file into the local DB. Only users with the Root Authority role are allowed to make the request.
   * @summary Imports new schema from a zip file.
   * @param {string} topicId Topic ID.
   * @param {any} body A zip file containing schema to be imported.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasTopicIdImportFilePost(
    topicId: string,
    body: any,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasTopicIdImportFilePost(topicId, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Imports new schema from IPFS into the local DB. Only users with the Root Authority role are allowed to make the request.
   * @summary Imports new schema from IPFS.
   * @param {string} topicId Topic ID.
   * @param {InlineObject2} inlineObject2
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasTopicIdImportMessagePost(
    topicId: string,
    inlineObject2: InlineObject2,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasTopicIdImportMessagePost(topicId, inlineObject2, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates new schema. Only users with the Root Authority role are allowed to make the request.
   * @summary Create new schema.
   * @param {string} topicId Topic ID.
   * @param {Schema} schema Object that contains a valid schema.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SchemasApi
   */
  public schemasTopicIdPost(
    topicId: string,
    schema: Schema,
    options?: AxiosRequestConfig,
  ) {
    return SchemasApiFp(this.configuration)
      .schemasTopicIdPost(topicId, schema, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns current settings. For users with the Root Authority role only.
     * @summary Returns current settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    settingsGet: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/settings`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set settings. For users with the Root Authority role only.
     * @summary Set settings.
     * @param {CommonSettings} commonSettings Settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    settingsPost: async (
      commonSettings: CommonSettings,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'commonSettings' is not null or undefined
      assertParamExists('settingsPost', 'commonSettings', commonSettings);
      const localVarPath = `/settings`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        commonSettings,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns current settings. For users with the Root Authority role only.
     * @summary Returns current settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async settingsGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSettings>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.settingsGet(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Set settings. For users with the Root Authority role only.
     * @summary Set settings.
     * @param {CommonSettings} commonSettings Settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async settingsPost(
      commonSettings: CommonSettings,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.settingsPost(
        commonSettings,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SettingsApiFp(configuration);
  return {
    /**
     * Returns current settings. For users with the Root Authority role only.
     * @summary Returns current settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    settingsGet(options?: any): AxiosPromise<CommonSettings> {
      return localVarFp
        .settingsGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Set settings. For users with the Root Authority role only.
     * @summary Set settings.
     * @param {CommonSettings} commonSettings Settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    settingsPost(
      commonSettings: CommonSettings,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .settingsPost(commonSettings, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
  /**
   * Returns current settings. For users with the Root Authority role only.
   * @summary Returns current settings.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SettingsApi
   */
  public settingsGet(options?: AxiosRequestConfig) {
    return SettingsApiFp(this.configuration)
      .settingsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Set settings. For users with the Root Authority role only.
   * @summary Set settings.
   * @param {CommonSettings} commonSettings Settings.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SettingsApi
   */
  public settingsPost(
    commonSettings: CommonSettings,
    options?: AxiosRequestConfig,
  ) {
    return SettingsApiFp(this.configuration)
      .settingsPost(commonSettings, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TokensApi - axios parameter creator
 * @export
 */
export const TokensApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns all tokens. For the Root Authority role it returns only the list of tokens, for other users it also returns token balances as well as the KYC, Freeze, and Association statuses. Not allowed for the Auditor role.
     * @summary Return a list of tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensGet: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/tokens`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new token. Only users with the Root Authority role are allowed to make the request.
     * @summary Creates a new token.
     * @param {Token} token Object that contains token information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensPost: async (
      token: Token,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'token' is not null or undefined
      assertParamExists('tokensPost', 'token', token);
      const localVarPath = `/tokens`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        token,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Associates the user with the provided Hedera token. Only users with the Installer role are allowed to make the request.
     * @summary Associates the user with the provided Hedera token.
     * @param {string} tokenId Token ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensTokenIdAssociatePut: async (
      tokenId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'tokenId' is not null or undefined
      assertParamExists('tokensTokenIdAssociatePut', 'tokenId', tokenId);
      const localVarPath = `/tokens/{tokenId}/associate`.replace(
        `{${'tokenId'}}`,
        encodeURIComponent(String(tokenId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Disassociates the user with the provided Hedera token. Only users with the Installer role are allowed to make the request.
     * @summary Associate the user with the provided Hedera token.
     * @param {string} tokenId Token ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensTokenIdDissociatePut: async (
      tokenId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'tokenId' is not null or undefined
      assertParamExists('tokensTokenIdDissociatePut', 'tokenId', tokenId);
      const localVarPath = `/tokens/{tokenId}/dissociate`.replace(
        `{${'tokenId'}}`,
        encodeURIComponent(String(tokenId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Freezes transfers of the specified token for the user. Only users with the Root Authority role are allowed to make the request.
     * @summary Freeze transfers of the specified token for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensTokenIdUsernameFreezePut: async (
      tokenId: string,
      username: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'tokenId' is not null or undefined
      assertParamExists('tokensTokenIdUsernameFreezePut', 'tokenId', tokenId);
      // verify required parameter 'username' is not null or undefined
      assertParamExists('tokensTokenIdUsernameFreezePut', 'username', username);
      const localVarPath = `/tokens/{tokenId}/{username}/freeze`
        .replace(`{${'tokenId'}}`, encodeURIComponent(String(tokenId)))
        .replace(`{${'username'}}`, encodeURIComponent(String(username)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Sets the KYC flag for the user. Only users with the Root Authority role are allowed to make the request.
     * @summary Sets the KYC flag for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensTokenIdUsernameGrantKycPut: async (
      tokenId: string,
      username: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'tokenId' is not null or undefined
      assertParamExists('tokensTokenIdUsernameGrantKycPut', 'tokenId', tokenId);
      // verify required parameter 'username' is not null or undefined
      assertParamExists(
        'tokensTokenIdUsernameGrantKycPut',
        'username',
        username,
      );
      const localVarPath = `/tokens/{tokenId}/{username}/grantKyc`
        .replace(`{${'tokenId'}}`, encodeURIComponent(String(tokenId)))
        .replace(`{${'username'}}`, encodeURIComponent(String(username)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns user information for the selected token. Only users with the Root Authority role are allowed to make the request.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensTokenIdUsernameInfoGet: async (
      tokenId: string,
      username: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'tokenId' is not null or undefined
      assertParamExists('tokensTokenIdUsernameInfoGet', 'tokenId', tokenId);
      // verify required parameter 'username' is not null or undefined
      assertParamExists('tokensTokenIdUsernameInfoGet', 'username', username);
      const localVarPath = `/tokens/{tokenId}/{username}/info`
        .replace(`{${'tokenId'}}`, encodeURIComponent(String(tokenId)))
        .replace(`{${'username'}}`, encodeURIComponent(String(username)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Unsets the KYC flag for the user. Only users with the Root Authority role are allowed to make the request.
     * @summary Unsets the KYC flag for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensTokenIdUsernameRevokeKycPut: async (
      tokenId: string,
      username: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'tokenId' is not null or undefined
      assertParamExists(
        'tokensTokenIdUsernameRevokeKycPut',
        'tokenId',
        tokenId,
      );
      // verify required parameter 'username' is not null or undefined
      assertParamExists(
        'tokensTokenIdUsernameRevokeKycPut',
        'username',
        username,
      );
      const localVarPath = `/tokens/{tokenId}/{username}/revokeKyc`
        .replace(`{${'tokenId'}}`, encodeURIComponent(String(tokenId)))
        .replace(`{${'username'}}`, encodeURIComponent(String(username)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Unfreezes transfers of the specified token for the user. Only users with the Root Authority role are allowed to make the request.
     * @summary Unfreezes transfers of the specified token for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensTokenIdUsernameUnfreezePut: async (
      tokenId: string,
      username: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'tokenId' is not null or undefined
      assertParamExists('tokensTokenIdUsernameUnfreezePut', 'tokenId', tokenId);
      // verify required parameter 'username' is not null or undefined
      assertParamExists(
        'tokensTokenIdUsernameUnfreezePut',
        'username',
        username,
      );
      const localVarPath = `/tokens/{tokenId}/{username}/unfreeze`
        .replace(`{${'tokenId'}}`, encodeURIComponent(String(tokenId)))
        .replace(`{${'username'}}`, encodeURIComponent(String(username)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TokensApi - functional programming interface
 * @export
 */
export const TokensApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TokensApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns all tokens. For the Root Authority role it returns only the list of tokens, for other users it also returns token balances as well as the KYC, Freeze, and Association statuses. Not allowed for the Auditor role.
     * @summary Return a list of tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tokensGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<TokenInfo & object>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.tokensGet(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Creates a new token. Only users with the Root Authority role are allowed to make the request.
     * @summary Creates a new token.
     * @param {Token} token Object that contains token information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tokensPost(
      token: Token,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<TokenInfo & object>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.tokensPost(
        token,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Associates the user with the provided Hedera token. Only users with the Installer role are allowed to make the request.
     * @summary Associates the user with the provided Hedera token.
     * @param {string} tokenId Token ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tokensTokenIdAssociatePut(
      tokenId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.tokensTokenIdAssociatePut(
          tokenId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Disassociates the user with the provided Hedera token. Only users with the Installer role are allowed to make the request.
     * @summary Associate the user with the provided Hedera token.
     * @param {string} tokenId Token ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tokensTokenIdDissociatePut(
      tokenId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.tokensTokenIdDissociatePut(
          tokenId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Freezes transfers of the specified token for the user. Only users with the Root Authority role are allowed to make the request.
     * @summary Freeze transfers of the specified token for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tokensTokenIdUsernameFreezePut(
      tokenId: string,
      username: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenInfo>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.tokensTokenIdUsernameFreezePut(
          tokenId,
          username,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Sets the KYC flag for the user. Only users with the Root Authority role are allowed to make the request.
     * @summary Sets the KYC flag for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tokensTokenIdUsernameGrantKycPut(
      tokenId: string,
      username: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenInfo>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.tokensTokenIdUsernameGrantKycPut(
          tokenId,
          username,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Returns user information for the selected token. Only users with the Root Authority role are allowed to make the request.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tokensTokenIdUsernameInfoGet(
      tokenId: string,
      username: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenInfo>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.tokensTokenIdUsernameInfoGet(
          tokenId,
          username,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Unsets the KYC flag for the user. Only users with the Root Authority role are allowed to make the request.
     * @summary Unsets the KYC flag for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tokensTokenIdUsernameRevokeKycPut(
      tokenId: string,
      username: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenInfo>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.tokensTokenIdUsernameRevokeKycPut(
          tokenId,
          username,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Unfreezes transfers of the specified token for the user. Only users with the Root Authority role are allowed to make the request.
     * @summary Unfreezes transfers of the specified token for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tokensTokenIdUsernameUnfreezePut(
      tokenId: string,
      username: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenInfo>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.tokensTokenIdUsernameUnfreezePut(
          tokenId,
          username,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * TokensApi - factory interface
 * @export
 */
export const TokensApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TokensApiFp(configuration);
  return {
    /**
     * Returns all tokens. For the Root Authority role it returns only the list of tokens, for other users it also returns token balances as well as the KYC, Freeze, and Association statuses. Not allowed for the Auditor role.
     * @summary Return a list of tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensGet(options?: any): AxiosPromise<Array<TokenInfo & object>> {
      return localVarFp
        .tokensGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a new token. Only users with the Root Authority role are allowed to make the request.
     * @summary Creates a new token.
     * @param {Token} token Object that contains token information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensPost(
      token: Token,
      options?: any,
    ): AxiosPromise<Array<TokenInfo & object>> {
      return localVarFp
        .tokensPost(token, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Associates the user with the provided Hedera token. Only users with the Installer role are allowed to make the request.
     * @summary Associates the user with the provided Hedera token.
     * @param {string} tokenId Token ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensTokenIdAssociatePut(
      tokenId: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .tokensTokenIdAssociatePut(tokenId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Disassociates the user with the provided Hedera token. Only users with the Installer role are allowed to make the request.
     * @summary Associate the user with the provided Hedera token.
     * @param {string} tokenId Token ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensTokenIdDissociatePut(
      tokenId: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .tokensTokenIdDissociatePut(tokenId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Freezes transfers of the specified token for the user. Only users with the Root Authority role are allowed to make the request.
     * @summary Freeze transfers of the specified token for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensTokenIdUsernameFreezePut(
      tokenId: string,
      username: string,
      options?: any,
    ): AxiosPromise<TokenInfo> {
      return localVarFp
        .tokensTokenIdUsernameFreezePut(tokenId, username, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Sets the KYC flag for the user. Only users with the Root Authority role are allowed to make the request.
     * @summary Sets the KYC flag for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensTokenIdUsernameGrantKycPut(
      tokenId: string,
      username: string,
      options?: any,
    ): AxiosPromise<TokenInfo> {
      return localVarFp
        .tokensTokenIdUsernameGrantKycPut(tokenId, username, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns user information for the selected token. Only users with the Root Authority role are allowed to make the request.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensTokenIdUsernameInfoGet(
      tokenId: string,
      username: string,
      options?: any,
    ): AxiosPromise<TokenInfo> {
      return localVarFp
        .tokensTokenIdUsernameInfoGet(tokenId, username, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Unsets the KYC flag for the user. Only users with the Root Authority role are allowed to make the request.
     * @summary Unsets the KYC flag for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensTokenIdUsernameRevokeKycPut(
      tokenId: string,
      username: string,
      options?: any,
    ): AxiosPromise<TokenInfo> {
      return localVarFp
        .tokensTokenIdUsernameRevokeKycPut(tokenId, username, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Unfreezes transfers of the specified token for the user. Only users with the Root Authority role are allowed to make the request.
     * @summary Unfreezes transfers of the specified token for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensTokenIdUsernameUnfreezePut(
      tokenId: string,
      username: string,
      options?: any,
    ): AxiosPromise<TokenInfo> {
      return localVarFp
        .tokensTokenIdUsernameUnfreezePut(tokenId, username, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TokensApi - object-oriented interface
 * @export
 * @class TokensApi
 * @extends {BaseAPI}
 */
export class TokensApi extends BaseAPI {
  /**
   * Returns all tokens. For the Root Authority role it returns only the list of tokens, for other users it also returns token balances as well as the KYC, Freeze, and Association statuses. Not allowed for the Auditor role.
   * @summary Return a list of tokens.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public tokensGet(options?: AxiosRequestConfig) {
    return TokensApiFp(this.configuration)
      .tokensGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new token. Only users with the Root Authority role are allowed to make the request.
   * @summary Creates a new token.
   * @param {Token} token Object that contains token information.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public tokensPost(token: Token, options?: AxiosRequestConfig) {
    return TokensApiFp(this.configuration)
      .tokensPost(token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Associates the user with the provided Hedera token. Only users with the Installer role are allowed to make the request.
   * @summary Associates the user with the provided Hedera token.
   * @param {string} tokenId Token ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public tokensTokenIdAssociatePut(
    tokenId: string,
    options?: AxiosRequestConfig,
  ) {
    return TokensApiFp(this.configuration)
      .tokensTokenIdAssociatePut(tokenId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Disassociates the user with the provided Hedera token. Only users with the Installer role are allowed to make the request.
   * @summary Associate the user with the provided Hedera token.
   * @param {string} tokenId Token ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public tokensTokenIdDissociatePut(
    tokenId: string,
    options?: AxiosRequestConfig,
  ) {
    return TokensApiFp(this.configuration)
      .tokensTokenIdDissociatePut(tokenId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Freezes transfers of the specified token for the user. Only users with the Root Authority role are allowed to make the request.
   * @summary Freeze transfers of the specified token for the user.
   * @param {string} tokenId Token ID.
   * @param {string} username Username.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public tokensTokenIdUsernameFreezePut(
    tokenId: string,
    username: string,
    options?: AxiosRequestConfig,
  ) {
    return TokensApiFp(this.configuration)
      .tokensTokenIdUsernameFreezePut(tokenId, username, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Sets the KYC flag for the user. Only users with the Root Authority role are allowed to make the request.
   * @summary Sets the KYC flag for the user.
   * @param {string} tokenId Token ID.
   * @param {string} username Username.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public tokensTokenIdUsernameGrantKycPut(
    tokenId: string,
    username: string,
    options?: AxiosRequestConfig,
  ) {
    return TokensApiFp(this.configuration)
      .tokensTokenIdUsernameGrantKycPut(tokenId, username, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns user information for the selected token. Only users with the Root Authority role are allowed to make the request.
   * @param {string} tokenId Token ID.
   * @param {string} username Username.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public tokensTokenIdUsernameInfoGet(
    tokenId: string,
    username: string,
    options?: AxiosRequestConfig,
  ) {
    return TokensApiFp(this.configuration)
      .tokensTokenIdUsernameInfoGet(tokenId, username, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Unsets the KYC flag for the user. Only users with the Root Authority role are allowed to make the request.
   * @summary Unsets the KYC flag for the user.
   * @param {string} tokenId Token ID.
   * @param {string} username Username.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public tokensTokenIdUsernameRevokeKycPut(
    tokenId: string,
    username: string,
    options?: AxiosRequestConfig,
  ) {
    return TokensApiFp(this.configuration)
      .tokensTokenIdUsernameRevokeKycPut(tokenId, username, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Unfreezes transfers of the specified token for the user. Only users with the Root Authority role are allowed to make the request.
   * @summary Unfreezes transfers of the specified token for the user.
   * @param {string} tokenId Token ID.
   * @param {string} username Username.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public tokensTokenIdUsernameUnfreezePut(
    tokenId: string,
    username: string,
    options?: AxiosRequestConfig,
  ) {
    return TokensApiFp(this.configuration)
      .tokensTokenIdUsernameUnfreezePut(tokenId, username, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TrustchainsApi - axios parameter creator
 * @export
 */
export const TrustchainsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Requests all VP documents. Only users with the Auditor role are allowed to make the request.
     * @summary Returns a list of all VP documents.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    trustchainsGet: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/trustchains`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Builds and returns a trustchain, from the VP to the root VC document. Only users with the Auditor role are allowed to make the request.
     * @summary Returns a trustchain for a VP document.
     * @param {string} hash Hash or ID of a VP document.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    trustchainsHashGet: async (
      hash: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'hash' is not null or undefined
      assertParamExists('trustchainsHashGet', 'hash', hash);
      const localVarPath = `/trustchains/{hash}`.replace(
        `{${'hash'}}`,
        encodeURIComponent(String(hash)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TrustchainsApi - functional programming interface
 * @export
 */
export const TrustchainsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    TrustchainsApiAxiosParamCreator(configuration);
  return {
    /**
     * Requests all VP documents. Only users with the Auditor role are allowed to make the request.
     * @summary Returns a list of all VP documents.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async trustchainsGet(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<VerifiablePresentation>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.trustchainsGet(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Builds and returns a trustchain, from the VP to the root VC document. Only users with the Auditor role are allowed to make the request.
     * @summary Returns a trustchain for a VP document.
     * @param {string} hash Hash or ID of a VP document.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async trustchainsHashGet(
      hash: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrustChains>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.trustchainsHashGet(hash, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * TrustchainsApi - factory interface
 * @export
 */
export const TrustchainsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TrustchainsApiFp(configuration);
  return {
    /**
     * Requests all VP documents. Only users with the Auditor role are allowed to make the request.
     * @summary Returns a list of all VP documents.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    trustchainsGet(options?: any): AxiosPromise<Array<VerifiablePresentation>> {
      return localVarFp
        .trustchainsGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Builds and returns a trustchain, from the VP to the root VC document. Only users with the Auditor role are allowed to make the request.
     * @summary Returns a trustchain for a VP document.
     * @param {string} hash Hash or ID of a VP document.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    trustchainsHashGet(hash: string, options?: any): AxiosPromise<TrustChains> {
      return localVarFp
        .trustchainsHashGet(hash, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TrustchainsApi - object-oriented interface
 * @export
 * @class TrustchainsApi
 * @extends {BaseAPI}
 */
export class TrustchainsApi extends BaseAPI {
  /**
   * Requests all VP documents. Only users with the Auditor role are allowed to make the request.
   * @summary Returns a list of all VP documents.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TrustchainsApi
   */
  public trustchainsGet(options?: AxiosRequestConfig) {
    return TrustchainsApiFp(this.configuration)
      .trustchainsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Builds and returns a trustchain, from the VP to the root VC document. Only users with the Auditor role are allowed to make the request.
   * @summary Returns a trustchain for a VP document.
   * @param {string} hash Hash or ID of a VP document.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TrustchainsApi
   */
  public trustchainsHashGet(hash: string, options?: AxiosRequestConfig) {
    return TrustchainsApiFp(this.configuration)
      .trustchainsHashGet(hash, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
