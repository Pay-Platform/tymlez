"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Guardian
 * The Guardian is a modular open-source solution that includes best-in-class identity management and decentralized ledger technology (DLT) libraries. At the heart of the Guardian solution is a sophisticated Policy Workflow Engine (PWE) that enables applications to offer a requirements-based tokenization implementation.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: info@envisionblockchain.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TrustchainsApi = exports.TrustchainsApiFactory = exports.TrustchainsApiFp = exports.TrustchainsApiAxiosParamCreator = exports.TokensApi = exports.TokensApiFactory = exports.TokensApiFp = exports.TokensApiAxiosParamCreator = exports.SettingsApi = exports.SettingsApiFactory = exports.SettingsApiFp = exports.SettingsApiAxiosParamCreator = exports.SchemasApi = exports.SchemasApiFactory = exports.SchemasApiFp = exports.SchemasApiAxiosParamCreator = exports.ProfilesApi = exports.ProfilesApiFactory = exports.ProfilesApiFp = exports.ProfilesApiAxiosParamCreator = exports.PoliciesApi = exports.PoliciesApiFactory = exports.PoliciesApiFp = exports.PoliciesApiAxiosParamCreator = exports.LogsApi = exports.LogsApiFactory = exports.LogsApiFp = exports.LogsApiAxiosParamCreator = exports.IpfsApi = exports.IpfsApiFactory = exports.IpfsApiFp = exports.IpfsApiAxiosParamCreator = exports.ExternalApi = exports.ExternalApiFactory = exports.ExternalApiFp = exports.ExternalApiAxiosParamCreator = exports.DemoApi = exports.DemoApiFactory = exports.DemoApiFp = exports.DemoApiAxiosParamCreator = exports.AccountsApi = exports.AccountsApiFactory = exports.AccountsApiFp = exports.AccountsApiAxiosParamCreator = exports.LogFiltersSortDirectionEnum = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
exports.LogFiltersSortDirectionEnum = {
    Asc: 'ASC',
    Desc: 'DESC',
};
/**
 * AccountsApi - axios parameter creator
 * @export
 */
const AccountsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns all users except those with roles Root Authority and Auditor. Only users with the Root Authority role are allowed to make the request.
         * @summary Returns a list of users, excluding Root Authority and Auditors.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsGet: async (options = {}) => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Logs user into the system.
         * @param {Credentials} credentials Object that contains username and password fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsLoginPost: async (credentials, options = {}) => {
            // verify required parameter 'credentials' is not null or undefined
            (0, common_1.assertParamExists)('accountsLoginPost', 'credentials', credentials);
            const localVarPath = `/accounts/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(credentials, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Registers a new user account.
         * @param {Credentials} credentials Object that contain username, password and role (optional) fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRegisterPost: async (credentials, options = {}) => {
            // verify required parameter 'credentials' is not null or undefined
            (0, common_1.assertParamExists)('accountsRegisterPost', 'credentials', credentials);
            const localVarPath = `/accounts/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(credentials, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all root authorities.
         * @summary Returns all root authorities.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRootAuthoritiesGet: async (options = {}) => {
            const localVarPath = `/accounts/root-authorities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns current user session.
         * @summary Returns current session of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsSessionGet: async (options = {}) => {
            const localVarPath = `/accounts/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AccountsApiAxiosParamCreator = AccountsApiAxiosParamCreator;
/**
 * AccountsApi - functional programming interface
 * @export
 */
const AccountsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AccountsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns all users except those with roles Root Authority and Auditor. Only users with the Root Authority role are allowed to make the request.
         * @summary Returns a list of users, excluding Root Authority and Auditors.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsGet(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsGet(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Logs user into the system.
         * @param {Credentials} credentials Object that contains username and password fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsLoginPost(credentials, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsLoginPost(credentials, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Registers a new user account.
         * @param {Credentials} credentials Object that contain username, password and role (optional) fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsRegisterPost(credentials, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsRegisterPost(credentials, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns all root authorities.
         * @summary Returns all root authorities.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsRootAuthoritiesGet(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsRootAuthoritiesGet(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns current user session.
         * @summary Returns current session of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsSessionGet(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsSessionGet(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.AccountsApiFp = AccountsApiFp;
/**
 * AccountsApi - factory interface
 * @export
 */
const AccountsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AccountsApiFp)(configuration);
    return {
        /**
         * Returns all users except those with roles Root Authority and Auditor. Only users with the Root Authority role are allowed to make the request.
         * @summary Returns a list of users, excluding Root Authority and Auditors.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsGet(options) {
            return localVarFp
                .accountsGet(options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Logs user into the system.
         * @param {Credentials} credentials Object that contains username and password fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsLoginPost(credentials, options) {
            return localVarFp
                .accountsLoginPost(credentials, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Registers a new user account.
         * @param {Credentials} credentials Object that contain username, password and role (optional) fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRegisterPost(credentials, options) {
            return localVarFp
                .accountsRegisterPost(credentials, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns all root authorities.
         * @summary Returns all root authorities.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRootAuthoritiesGet(options) {
            return localVarFp
                .accountsRootAuthoritiesGet(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns current user session.
         * @summary Returns current session of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsSessionGet(options) {
            return localVarFp
                .accountsSessionGet(options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.AccountsApiFactory = AccountsApiFactory;
/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
class AccountsApi extends base_1.BaseAPI {
    /**
     * Returns all users except those with roles Root Authority and Auditor. Only users with the Root Authority role are allowed to make the request.
     * @summary Returns a list of users, excluding Root Authority and Auditors.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsGet(options) {
        return (0, exports.AccountsApiFp)(this.configuration)
            .accountsGet(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Logs user into the system.
     * @param {Credentials} credentials Object that contains username and password fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsLoginPost(credentials, options) {
        return (0, exports.AccountsApiFp)(this.configuration)
            .accountsLoginPost(credentials, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Registers a new user account.
     * @param {Credentials} credentials Object that contain username, password and role (optional) fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsRegisterPost(credentials, options) {
        return (0, exports.AccountsApiFp)(this.configuration)
            .accountsRegisterPost(credentials, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all root authorities.
     * @summary Returns all root authorities.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsRootAuthoritiesGet(options) {
        return (0, exports.AccountsApiFp)(this.configuration)
            .accountsRootAuthoritiesGet(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns current user session.
     * @summary Returns current session of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    accountsSessionGet(options) {
        return (0, exports.AccountsApiFp)(this.configuration)
            .accountsSessionGet(options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.AccountsApi = AccountsApi;
/**
 * DemoApi - axios parameter creator
 * @export
 */
const DemoApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Generates a new Hedera account with a random private key.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        demoRandomKeyGet: async (options = {}) => {
            const localVarPath = `/demo/randomKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all registered user accounts.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        demoRegisteredUsersGet: async (options = {}) => {
            const localVarPath = `/demo/registeredUsers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.DemoApiAxiosParamCreator = DemoApiAxiosParamCreator;
/**
 * DemoApi - functional programming interface
 * @export
 */
const DemoApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.DemoApiAxiosParamCreator)(configuration);
    return {
        /**
         * Generates a new Hedera account with a random private key.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async demoRandomKeyGet(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.demoRandomKeyGet(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns all registered user accounts.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async demoRegisteredUsersGet(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.demoRegisteredUsersGet(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.DemoApiFp = DemoApiFp;
/**
 * DemoApi - factory interface
 * @export
 */
const DemoApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.DemoApiFp)(configuration);
    return {
        /**
         * Generates a new Hedera account with a random private key.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        demoRandomKeyGet(options) {
            return localVarFp
                .demoRandomKeyGet(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns all registered user accounts.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        demoRegisteredUsersGet(options) {
            return localVarFp
                .demoRegisteredUsersGet(options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.DemoApiFactory = DemoApiFactory;
/**
 * DemoApi - object-oriented interface
 * @export
 * @class DemoApi
 * @extends {BaseAPI}
 */
class DemoApi extends base_1.BaseAPI {
    /**
     * Generates a new Hedera account with a random private key.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DemoApi
     */
    demoRandomKeyGet(options) {
        return (0, exports.DemoApiFp)(this.configuration)
            .demoRandomKeyGet(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all registered user accounts.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DemoApi
     */
    demoRegisteredUsersGet(options) {
        return (0, exports.DemoApiFp)(this.configuration)
            .demoRegisteredUsersGet(options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.DemoApi = DemoApi;
/**
 * ExternalApi - axios parameter creator
 * @export
 */
const ExternalApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Sends data from an external source.
         * @summary Sends data from an external source.
         * @param {ExternalData} externalData Object that contains a VC Document.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalPost: async (externalData, options = {}) => {
            // verify required parameter 'externalData' is not null or undefined
            (0, common_1.assertParamExists)('externalPost', 'externalData', externalData);
            const localVarPath = `/external`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(externalData, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ExternalApiAxiosParamCreator = ExternalApiAxiosParamCreator;
/**
 * ExternalApi - functional programming interface
 * @export
 */
const ExternalApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ExternalApiAxiosParamCreator)(configuration);
    return {
        /**
         * Sends data from an external source.
         * @summary Sends data from an external source.
         * @param {ExternalData} externalData Object that contains a VC Document.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async externalPost(externalData, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.externalPost(externalData, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.ExternalApiFp = ExternalApiFp;
/**
 * ExternalApi - factory interface
 * @export
 */
const ExternalApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ExternalApiFp)(configuration);
    return {
        /**
         * Sends data from an external source.
         * @summary Sends data from an external source.
         * @param {ExternalData} externalData Object that contains a VC Document.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalPost(externalData, options) {
            return localVarFp
                .externalPost(externalData, options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.ExternalApiFactory = ExternalApiFactory;
/**
 * ExternalApi - object-oriented interface
 * @export
 * @class ExternalApi
 * @extends {BaseAPI}
 */
class ExternalApi extends base_1.BaseAPI {
    /**
     * Sends data from an external source.
     * @summary Sends data from an external source.
     * @param {ExternalData} externalData Object that contains a VC Document.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalApi
     */
    externalPost(externalData, options) {
        return (0, exports.ExternalApiFp)(this.configuration)
            .externalPost(externalData, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.ExternalApi = ExternalApi;
/**
 * IpfsApi - axios parameter creator
 * @export
 */
const IpfsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Add file to ipfs.
         * @summary Add file to ipfs.
         * @param {any} body Data array of file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipfsFilePost: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('ipfsFilePost', 'body', body);
            const localVarPath = `/ipfs/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'binary/octet-stream';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.IpfsApiAxiosParamCreator = IpfsApiAxiosParamCreator;
/**
 * IpfsApi - functional programming interface
 * @export
 */
const IpfsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.IpfsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Add file to ipfs.
         * @summary Add file to ipfs.
         * @param {any} body Data array of file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipfsFilePost(body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipfsFilePost(body, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.IpfsApiFp = IpfsApiFp;
/**
 * IpfsApi - factory interface
 * @export
 */
const IpfsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.IpfsApiFp)(configuration);
    return {
        /**
         * Add file to ipfs.
         * @summary Add file to ipfs.
         * @param {any} body Data array of file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipfsFilePost(body, options) {
            return localVarFp
                .ipfsFilePost(body, options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.IpfsApiFactory = IpfsApiFactory;
/**
 * IpfsApi - object-oriented interface
 * @export
 * @class IpfsApi
 * @extends {BaseAPI}
 */
class IpfsApi extends base_1.BaseAPI {
    /**
     * Add file to ipfs.
     * @summary Add file to ipfs.
     * @param {any} body Data array of file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpfsApi
     */
    ipfsFilePost(body, options) {
        return (0, exports.IpfsApiFp)(this.configuration)
            .ipfsFilePost(body, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.IpfsApi = IpfsApi;
/**
 * LogsApi - axios parameter creator
 * @export
 */
const LogsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns logs attributes. For users with the Root Authority role only.
         * @summary Returns logs attributes.
         * @param {string} [name] Part of name.
         * @param {Array<string>} [existingAttributes] Attributes to exclude.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsAttributesGet: async (name, existingAttributes, options = {}) => {
            const localVarPath = `/logs/attributes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (existingAttributes) {
                localVarQueryParameter['existingAttributes'] = existingAttributes;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns logs. For users with the Root Authority role only.
         * @summary Returns logs.
         * @param {LogFilters} [logFilters] Log filters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsPost: async (logFilters, options = {}) => {
            const localVarPath = `/logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(logFilters, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.LogsApiAxiosParamCreator = LogsApiAxiosParamCreator;
/**
 * LogsApi - functional programming interface
 * @export
 */
const LogsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.LogsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns logs attributes. For users with the Root Authority role only.
         * @summary Returns logs attributes.
         * @param {string} [name] Part of name.
         * @param {Array<string>} [existingAttributes] Attributes to exclude.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsAttributesGet(name, existingAttributes, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsAttributesGet(name, existingAttributes, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns logs. For users with the Root Authority role only.
         * @summary Returns logs.
         * @param {LogFilters} [logFilters] Log filters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsPost(logFilters, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsPost(logFilters, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.LogsApiFp = LogsApiFp;
/**
 * LogsApi - factory interface
 * @export
 */
const LogsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.LogsApiFp)(configuration);
    return {
        /**
         * Returns logs attributes. For users with the Root Authority role only.
         * @summary Returns logs attributes.
         * @param {string} [name] Part of name.
         * @param {Array<string>} [existingAttributes] Attributes to exclude.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsAttributesGet(name, existingAttributes, options) {
            return localVarFp
                .logsAttributesGet(name, existingAttributes, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns logs. For users with the Root Authority role only.
         * @summary Returns logs.
         * @param {LogFilters} [logFilters] Log filters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsPost(logFilters, options) {
            return localVarFp
                .logsPost(logFilters, options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.LogsApiFactory = LogsApiFactory;
/**
 * LogsApi - object-oriented interface
 * @export
 * @class LogsApi
 * @extends {BaseAPI}
 */
class LogsApi extends base_1.BaseAPI {
    /**
     * Returns logs attributes. For users with the Root Authority role only.
     * @summary Returns logs attributes.
     * @param {string} [name] Part of name.
     * @param {Array<string>} [existingAttributes] Attributes to exclude.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsApi
     */
    logsAttributesGet(name, existingAttributes, options) {
        return (0, exports.LogsApiFp)(this.configuration)
            .logsAttributesGet(name, existingAttributes, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns logs. For users with the Root Authority role only.
     * @summary Returns logs.
     * @param {LogFilters} [logFilters] Log filters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsApi
     */
    logsPost(logFilters, options) {
        return (0, exports.LogsApiFp)(this.configuration)
            .logsPost(logFilters, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.LogsApi = LogsApi;
/**
 * PoliciesApi - axios parameter creator
 * @export
 */
const PoliciesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns all policies. Only users with the Root Authority and Installer role are allowed to make the request.
         * @summary Return a list of all policies.
         * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
         * @param {number} [pageSize] The numbers of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesGet: async (pageIndex, pageSize, options = {}) => {
            const localVarPath = `/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (pageIndex !== undefined) {
                localVarQueryParameter['pageIndex'] = pageIndex;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Imports new policy and all associated artifacts, such as schemas and VCs, from the provided zip file into the local DB. Only users with the Root Authority role are allowed to make the request.
         * @summary Imports new policy from a zip file.
         * @param {any} body A zip file that contains the policy and associated schemas and VCs to be imported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesImportFilePost: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('policiesImportFilePost', 'body', body);
            const localVarPath = `/policies/import/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'binary/octet-stream';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Previews the policy from a zip file without loading it into the local DB. Only users with the Root Authority role are allowed to make the request.
         * @summary Policy preview from a zip file.
         * @param {any} body A zip file that contains the policy and associated schemas and VCs to be viewed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesImportFilePreviewPost: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('policiesImportFilePreviewPost', 'body', body);
            const localVarPath = `/policies/import/file/preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'binary/octet-stream';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Imports new policy and all associated artifacts from IPFS into the local DB. Only users with the Root Authority role are allowed to make the request.
         * @summary Imports new policy from IPFS.
         * @param {InlineObject5} inlineObject5
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesImportMessagePost: async (inlineObject5, options = {}) => {
            // verify required parameter 'inlineObject5' is not null or undefined
            (0, common_1.assertParamExists)('policiesImportMessagePost', 'inlineObject5', inlineObject5);
            const localVarPath = `/policies/import/message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(inlineObject5, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Previews the policy from IPFS without loading it into the local DB. Only users with the Root Authority role are allowed to make the request.
         * @summary Policy preview from IPFS.
         * @param {InlineObject6} inlineObject6
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesImportMessagePreviewPost: async (inlineObject6, options = {}) => {
            // verify required parameter 'inlineObject6' is not null or undefined
            (0, common_1.assertParamExists)('policiesImportMessagePreviewPost', 'inlineObject6', inlineObject6);
            const localVarPath = `/policies/import/message/preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(inlineObject6, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns data from the root policy block. Only users with the Root Authority and Installer role are allowed to make the request.
         * @summary Retrieves data for the policy root block.
         * @param {string} policyId Selected policy ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdBlocksGet: async (policyId, options = {}) => {
            // verify required parameter 'policyId' is not null or undefined
            (0, common_1.assertParamExists)('policiesPolicyIdBlocksGet', 'policyId', policyId);
            const localVarPath = `/policies/{policyId}/blocks`.replace(`{${'policyId'}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests block data. Only users with a role that described in block are allowed to make the request.
         * @summary Requests block data.
         * @param {string} policyId Selected policy ID.
         * @param {string} uuid Selected block UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdBlocksUuidGet: async (policyId, uuid, options = {}) => {
            // verify required parameter 'policyId' is not null or undefined
            (0, common_1.assertParamExists)('policiesPolicyIdBlocksUuidGet', 'policyId', policyId);
            // verify required parameter 'uuid' is not null or undefined
            (0, common_1.assertParamExists)('policiesPolicyIdBlocksUuidGet', 'uuid', uuid);
            const localVarPath = `/policies/{policyId}/blocks/{uuid}`
                .replace(`{${'policyId'}}`, encodeURIComponent(String(policyId)))
                .replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends data to the specified block.
         * @summary Sends data to the specified block.
         * @param {string} policyId Selected policy ID.
         * @param {string} uuid Selected block UUID.
         * @param {object} body Object with the data to be sent to the block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdBlocksUuidPost: async (policyId, uuid, body, options = {}) => {
            // verify required parameter 'policyId' is not null or undefined
            (0, common_1.assertParamExists)('policiesPolicyIdBlocksUuidPost', 'policyId', policyId);
            // verify required parameter 'uuid' is not null or undefined
            (0, common_1.assertParamExists)('policiesPolicyIdBlocksUuidPost', 'uuid', uuid);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('policiesPolicyIdBlocksUuidPost', 'body', body);
            const localVarPath = `/policies/{policyId}/blocks/{uuid}`
                .replace(`{${'policyId'}}`, encodeURIComponent(String(policyId)))
                .replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a zip file containing the published policy and all associated artifacts, i.e. schemas and VCs. Only users with the Root Authority role are allowed to make the request.
         * @summary Return policy and its artifacts in a zip file format for the specified policy.
         * @param {string} policyId Selected policy ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdExportFileGet: async (policyId, options = {}) => {
            // verify required parameter 'policyId' is not null or undefined
            (0, common_1.assertParamExists)('policiesPolicyIdExportFileGet', 'policyId', policyId);
            const localVarPath = `/policies/{policyId}/export/file`.replace(`{${'policyId'}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Hedera message ID for the specified policy published onto IPFS. Only users with the Root Authority role are allowed to make the request.
         * @summary Return Heder message ID for the specified published policy.
         * @param {string} policyId Selected policy ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdExportMessageGet: async (policyId, options = {}) => {
            // verify required parameter 'policyId' is not null or undefined
            (0, common_1.assertParamExists)('policiesPolicyIdExportMessageGet', 'policyId', policyId);
            const localVarPath = `/policies/{policyId}/export/message`.replace(`{${'policyId'}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves policy configuration for the specified policy ID. Only users with the Root Authority role are allowed to make the request.
         * @summary Retrieves policy configuration.
         * @param {string} policyId Selected policy ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdGet: async (policyId, options = {}) => {
            // verify required parameter 'policyId' is not null or undefined
            (0, common_1.assertParamExists)('policiesPolicyIdGet', 'policyId', policyId);
            const localVarPath = `/policies/{policyId}`.replace(`{${'policyId'}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Publishes the policy with the specified (internal) policy ID onto IPFS, sends a message featuring its IPFS CID into the corresponding Hedera topic. Only users with the Root Authority role are allowed to make the request.
         * @summary Publishes the policy onto IPFS.
         * @param {string} policyId Selected policy ID.
         * @param {InlineObject4} inlineObject4
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdPublishPut: async (policyId, inlineObject4, options = {}) => {
            // verify required parameter 'policyId' is not null or undefined
            (0, common_1.assertParamExists)('policiesPolicyIdPublishPut', 'policyId', policyId);
            // verify required parameter 'inlineObject4' is not null or undefined
            (0, common_1.assertParamExists)('policiesPolicyIdPublishPut', 'inlineObject4', inlineObject4);
            const localVarPath = `/policies/{policyId}/publish`.replace(`{${'policyId'}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'PUT',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(inlineObject4, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates policy configuration for the specified policy ID. Only users with the Root Authority role are allowed to make the request.
         * @summary Updates policy configuration.
         * @param {string} policyId Selected policy ID.
         * @param {PolicyConfig} policyConfig Object that contains policy configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdPut: async (policyId, policyConfig, options = {}) => {
            // verify required parameter 'policyId' is not null or undefined
            (0, common_1.assertParamExists)('policiesPolicyIdPut', 'policyId', policyId);
            // verify required parameter 'policyConfig' is not null or undefined
            (0, common_1.assertParamExists)('policiesPolicyIdPut', 'policyConfig', policyConfig);
            const localVarPath = `/policies/{policyId}`.replace(`{${'policyId'}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'PUT',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(policyConfig, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests block ID from a policy by tag. Only users with the Root Authority and Installer roles are allowed to make the request.
         * @summary Requests block ID from a policy by tag.
         * @param {string} policyId Selected policy ID.
         * @param {string} tag Tag from the selected policy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdTagTagGet: async (policyId, tag, options = {}) => {
            // verify required parameter 'policyId' is not null or undefined
            (0, common_1.assertParamExists)('policiesPolicyIdTagTagGet', 'policyId', policyId);
            // verify required parameter 'tag' is not null or undefined
            (0, common_1.assertParamExists)('policiesPolicyIdTagTagGet', 'tag', tag);
            const localVarPath = `/policies/{policyId}/tag/{tag}`
                .replace(`{${'policyId'}}`, encodeURIComponent(String(policyId)))
                .replace(`{${'tag'}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new policy. Only users with the Root Authority role are allowed to make the request.
         * @summary Creates a new policy.
         * @param {PolicyConfig} policyConfig Object that contains policy configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPost: async (policyConfig, options = {}) => {
            // verify required parameter 'policyConfig' is not null or undefined
            (0, common_1.assertParamExists)('policiesPost', 'policyConfig', policyConfig);
            const localVarPath = `/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(policyConfig, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates selected policy. Only users with the Root Authority role are allowed to make the request.
         * @summary Validates policy.
         * @param {PolicyConfig} policyConfig Object that contains policy configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesValidatePost: async (policyConfig, options = {}) => {
            // verify required parameter 'policyConfig' is not null or undefined
            (0, common_1.assertParamExists)('policiesValidatePost', 'policyConfig', policyConfig);
            const localVarPath = `/policies/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(policyConfig, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.PoliciesApiAxiosParamCreator = PoliciesApiAxiosParamCreator;
/**
 * PoliciesApi - functional programming interface
 * @export
 */
const PoliciesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PoliciesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns all policies. Only users with the Root Authority and Installer role are allowed to make the request.
         * @summary Return a list of all policies.
         * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
         * @param {number} [pageSize] The numbers of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesGet(pageIndex, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesGet(pageIndex, pageSize, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Imports new policy and all associated artifacts, such as schemas and VCs, from the provided zip file into the local DB. Only users with the Root Authority role are allowed to make the request.
         * @summary Imports new policy from a zip file.
         * @param {any} body A zip file that contains the policy and associated schemas and VCs to be imported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesImportFilePost(body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesImportFilePost(body, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Previews the policy from a zip file without loading it into the local DB. Only users with the Root Authority role are allowed to make the request.
         * @summary Policy preview from a zip file.
         * @param {any} body A zip file that contains the policy and associated schemas and VCs to be viewed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesImportFilePreviewPost(body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesImportFilePreviewPost(body, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Imports new policy and all associated artifacts from IPFS into the local DB. Only users with the Root Authority role are allowed to make the request.
         * @summary Imports new policy from IPFS.
         * @param {InlineObject5} inlineObject5
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesImportMessagePost(inlineObject5, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesImportMessagePost(inlineObject5, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Previews the policy from IPFS without loading it into the local DB. Only users with the Root Authority role are allowed to make the request.
         * @summary Policy preview from IPFS.
         * @param {InlineObject6} inlineObject6
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesImportMessagePreviewPost(inlineObject6, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesImportMessagePreviewPost(inlineObject6, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns data from the root policy block. Only users with the Root Authority and Installer role are allowed to make the request.
         * @summary Retrieves data for the policy root block.
         * @param {string} policyId Selected policy ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdBlocksGet(policyId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdBlocksGet(policyId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Requests block data. Only users with a role that described in block are allowed to make the request.
         * @summary Requests block data.
         * @param {string} policyId Selected policy ID.
         * @param {string} uuid Selected block UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdBlocksUuidGet(policyId, uuid, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdBlocksUuidGet(policyId, uuid, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Sends data to the specified block.
         * @summary Sends data to the specified block.
         * @param {string} policyId Selected policy ID.
         * @param {string} uuid Selected block UUID.
         * @param {object} body Object with the data to be sent to the block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdBlocksUuidPost(policyId, uuid, body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdBlocksUuidPost(policyId, uuid, body, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns a zip file containing the published policy and all associated artifacts, i.e. schemas and VCs. Only users with the Root Authority role are allowed to make the request.
         * @summary Return policy and its artifacts in a zip file format for the specified policy.
         * @param {string} policyId Selected policy ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdExportFileGet(policyId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdExportFileGet(policyId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns the Hedera message ID for the specified policy published onto IPFS. Only users with the Root Authority role are allowed to make the request.
         * @summary Return Heder message ID for the specified published policy.
         * @param {string} policyId Selected policy ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdExportMessageGet(policyId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdExportMessageGet(policyId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Retrieves policy configuration for the specified policy ID. Only users with the Root Authority role are allowed to make the request.
         * @summary Retrieves policy configuration.
         * @param {string} policyId Selected policy ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdGet(policyId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdGet(policyId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Publishes the policy with the specified (internal) policy ID onto IPFS, sends a message featuring its IPFS CID into the corresponding Hedera topic. Only users with the Root Authority role are allowed to make the request.
         * @summary Publishes the policy onto IPFS.
         * @param {string} policyId Selected policy ID.
         * @param {InlineObject4} inlineObject4
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdPublishPut(policyId, inlineObject4, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdPublishPut(policyId, inlineObject4, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Updates policy configuration for the specified policy ID. Only users with the Root Authority role are allowed to make the request.
         * @summary Updates policy configuration.
         * @param {string} policyId Selected policy ID.
         * @param {PolicyConfig} policyConfig Object that contains policy configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdPut(policyId, policyConfig, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdPut(policyId, policyConfig, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Requests block ID from a policy by tag. Only users with the Root Authority and Installer roles are allowed to make the request.
         * @summary Requests block ID from a policy by tag.
         * @param {string} policyId Selected policy ID.
         * @param {string} tag Tag from the selected policy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdTagTagGet(policyId, tag, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdTagTagGet(policyId, tag, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Creates a new policy. Only users with the Root Authority role are allowed to make the request.
         * @summary Creates a new policy.
         * @param {PolicyConfig} policyConfig Object that contains policy configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPost(policyConfig, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPost(policyConfig, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Validates selected policy. Only users with the Root Authority role are allowed to make the request.
         * @summary Validates policy.
         * @param {PolicyConfig} policyConfig Object that contains policy configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesValidatePost(policyConfig, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesValidatePost(policyConfig, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.PoliciesApiFp = PoliciesApiFp;
/**
 * PoliciesApi - factory interface
 * @export
 */
const PoliciesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PoliciesApiFp)(configuration);
    return {
        /**
         * Returns all policies. Only users with the Root Authority and Installer role are allowed to make the request.
         * @summary Return a list of all policies.
         * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
         * @param {number} [pageSize] The numbers of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesGet(pageIndex, pageSize, options) {
            return localVarFp
                .policiesGet(pageIndex, pageSize, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Imports new policy and all associated artifacts, such as schemas and VCs, from the provided zip file into the local DB. Only users with the Root Authority role are allowed to make the request.
         * @summary Imports new policy from a zip file.
         * @param {any} body A zip file that contains the policy and associated schemas and VCs to be imported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesImportFilePost(body, options) {
            return localVarFp
                .policiesImportFilePost(body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Previews the policy from a zip file without loading it into the local DB. Only users with the Root Authority role are allowed to make the request.
         * @summary Policy preview from a zip file.
         * @param {any} body A zip file that contains the policy and associated schemas and VCs to be viewed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesImportFilePreviewPost(body, options) {
            return localVarFp
                .policiesImportFilePreviewPost(body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Imports new policy and all associated artifacts from IPFS into the local DB. Only users with the Root Authority role are allowed to make the request.
         * @summary Imports new policy from IPFS.
         * @param {InlineObject5} inlineObject5
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesImportMessagePost(inlineObject5, options) {
            return localVarFp
                .policiesImportMessagePost(inlineObject5, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Previews the policy from IPFS without loading it into the local DB. Only users with the Root Authority role are allowed to make the request.
         * @summary Policy preview from IPFS.
         * @param {InlineObject6} inlineObject6
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesImportMessagePreviewPost(inlineObject6, options) {
            return localVarFp
                .policiesImportMessagePreviewPost(inlineObject6, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns data from the root policy block. Only users with the Root Authority and Installer role are allowed to make the request.
         * @summary Retrieves data for the policy root block.
         * @param {string} policyId Selected policy ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdBlocksGet(policyId, options) {
            return localVarFp
                .policiesPolicyIdBlocksGet(policyId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requests block data. Only users with a role that described in block are allowed to make the request.
         * @summary Requests block data.
         * @param {string} policyId Selected policy ID.
         * @param {string} uuid Selected block UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdBlocksUuidGet(policyId, uuid, options) {
            return localVarFp
                .policiesPolicyIdBlocksUuidGet(policyId, uuid, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Sends data to the specified block.
         * @summary Sends data to the specified block.
         * @param {string} policyId Selected policy ID.
         * @param {string} uuid Selected block UUID.
         * @param {object} body Object with the data to be sent to the block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdBlocksUuidPost(policyId, uuid, body, options) {
            return localVarFp
                .policiesPolicyIdBlocksUuidPost(policyId, uuid, body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns a zip file containing the published policy and all associated artifacts, i.e. schemas and VCs. Only users with the Root Authority role are allowed to make the request.
         * @summary Return policy and its artifacts in a zip file format for the specified policy.
         * @param {string} policyId Selected policy ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdExportFileGet(policyId, options) {
            return localVarFp
                .policiesPolicyIdExportFileGet(policyId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns the Hedera message ID for the specified policy published onto IPFS. Only users with the Root Authority role are allowed to make the request.
         * @summary Return Heder message ID for the specified published policy.
         * @param {string} policyId Selected policy ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdExportMessageGet(policyId, options) {
            return localVarFp
                .policiesPolicyIdExportMessageGet(policyId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Retrieves policy configuration for the specified policy ID. Only users with the Root Authority role are allowed to make the request.
         * @summary Retrieves policy configuration.
         * @param {string} policyId Selected policy ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdGet(policyId, options) {
            return localVarFp
                .policiesPolicyIdGet(policyId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Publishes the policy with the specified (internal) policy ID onto IPFS, sends a message featuring its IPFS CID into the corresponding Hedera topic. Only users with the Root Authority role are allowed to make the request.
         * @summary Publishes the policy onto IPFS.
         * @param {string} policyId Selected policy ID.
         * @param {InlineObject4} inlineObject4
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdPublishPut(policyId, inlineObject4, options) {
            return localVarFp
                .policiesPolicyIdPublishPut(policyId, inlineObject4, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Updates policy configuration for the specified policy ID. Only users with the Root Authority role are allowed to make the request.
         * @summary Updates policy configuration.
         * @param {string} policyId Selected policy ID.
         * @param {PolicyConfig} policyConfig Object that contains policy configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdPut(policyId, policyConfig, options) {
            return localVarFp
                .policiesPolicyIdPut(policyId, policyConfig, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Requests block ID from a policy by tag. Only users with the Root Authority and Installer roles are allowed to make the request.
         * @summary Requests block ID from a policy by tag.
         * @param {string} policyId Selected policy ID.
         * @param {string} tag Tag from the selected policy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdTagTagGet(policyId, tag, options) {
            return localVarFp
                .policiesPolicyIdTagTagGet(policyId, tag, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Creates a new policy. Only users with the Root Authority role are allowed to make the request.
         * @summary Creates a new policy.
         * @param {PolicyConfig} policyConfig Object that contains policy configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPost(policyConfig, options) {
            return localVarFp
                .policiesPost(policyConfig, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Validates selected policy. Only users with the Root Authority role are allowed to make the request.
         * @summary Validates policy.
         * @param {PolicyConfig} policyConfig Object that contains policy configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesValidatePost(policyConfig, options) {
            return localVarFp
                .policiesValidatePost(policyConfig, options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.PoliciesApiFactory = PoliciesApiFactory;
/**
 * PoliciesApi - object-oriented interface
 * @export
 * @class PoliciesApi
 * @extends {BaseAPI}
 */
class PoliciesApi extends base_1.BaseAPI {
    /**
     * Returns all policies. Only users with the Root Authority and Installer role are allowed to make the request.
     * @summary Return a list of all policies.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    policiesGet(pageIndex, pageSize, options) {
        return (0, exports.PoliciesApiFp)(this.configuration)
            .policiesGet(pageIndex, pageSize, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Imports new policy and all associated artifacts, such as schemas and VCs, from the provided zip file into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Imports new policy from a zip file.
     * @param {any} body A zip file that contains the policy and associated schemas and VCs to be imported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    policiesImportFilePost(body, options) {
        return (0, exports.PoliciesApiFp)(this.configuration)
            .policiesImportFilePost(body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Previews the policy from a zip file without loading it into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Policy preview from a zip file.
     * @param {any} body A zip file that contains the policy and associated schemas and VCs to be viewed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    policiesImportFilePreviewPost(body, options) {
        return (0, exports.PoliciesApiFp)(this.configuration)
            .policiesImportFilePreviewPost(body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Imports new policy and all associated artifacts from IPFS into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Imports new policy from IPFS.
     * @param {InlineObject5} inlineObject5
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    policiesImportMessagePost(inlineObject5, options) {
        return (0, exports.PoliciesApiFp)(this.configuration)
            .policiesImportMessagePost(inlineObject5, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Previews the policy from IPFS without loading it into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Policy preview from IPFS.
     * @param {InlineObject6} inlineObject6
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    policiesImportMessagePreviewPost(inlineObject6, options) {
        return (0, exports.PoliciesApiFp)(this.configuration)
            .policiesImportMessagePreviewPost(inlineObject6, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns data from the root policy block. Only users with the Root Authority and Installer role are allowed to make the request.
     * @summary Retrieves data for the policy root block.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    policiesPolicyIdBlocksGet(policyId, options) {
        return (0, exports.PoliciesApiFp)(this.configuration)
            .policiesPolicyIdBlocksGet(policyId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requests block data. Only users with a role that described in block are allowed to make the request.
     * @summary Requests block data.
     * @param {string} policyId Selected policy ID.
     * @param {string} uuid Selected block UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    policiesPolicyIdBlocksUuidGet(policyId, uuid, options) {
        return (0, exports.PoliciesApiFp)(this.configuration)
            .policiesPolicyIdBlocksUuidGet(policyId, uuid, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sends data to the specified block.
     * @summary Sends data to the specified block.
     * @param {string} policyId Selected policy ID.
     * @param {string} uuid Selected block UUID.
     * @param {object} body Object with the data to be sent to the block.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    policiesPolicyIdBlocksUuidPost(policyId, uuid, body, options) {
        return (0, exports.PoliciesApiFp)(this.configuration)
            .policiesPolicyIdBlocksUuidPost(policyId, uuid, body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a zip file containing the published policy and all associated artifacts, i.e. schemas and VCs. Only users with the Root Authority role are allowed to make the request.
     * @summary Return policy and its artifacts in a zip file format for the specified policy.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    policiesPolicyIdExportFileGet(policyId, options) {
        return (0, exports.PoliciesApiFp)(this.configuration)
            .policiesPolicyIdExportFileGet(policyId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the Hedera message ID for the specified policy published onto IPFS. Only users with the Root Authority role are allowed to make the request.
     * @summary Return Heder message ID for the specified published policy.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    policiesPolicyIdExportMessageGet(policyId, options) {
        return (0, exports.PoliciesApiFp)(this.configuration)
            .policiesPolicyIdExportMessageGet(policyId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves policy configuration for the specified policy ID. Only users with the Root Authority role are allowed to make the request.
     * @summary Retrieves policy configuration.
     * @param {string} policyId Selected policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    policiesPolicyIdGet(policyId, options) {
        return (0, exports.PoliciesApiFp)(this.configuration)
            .policiesPolicyIdGet(policyId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Publishes the policy with the specified (internal) policy ID onto IPFS, sends a message featuring its IPFS CID into the corresponding Hedera topic. Only users with the Root Authority role are allowed to make the request.
     * @summary Publishes the policy onto IPFS.
     * @param {string} policyId Selected policy ID.
     * @param {InlineObject4} inlineObject4
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    policiesPolicyIdPublishPut(policyId, inlineObject4, options) {
        return (0, exports.PoliciesApiFp)(this.configuration)
            .policiesPolicyIdPublishPut(policyId, inlineObject4, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates policy configuration for the specified policy ID. Only users with the Root Authority role are allowed to make the request.
     * @summary Updates policy configuration.
     * @param {string} policyId Selected policy ID.
     * @param {PolicyConfig} policyConfig Object that contains policy configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    policiesPolicyIdPut(policyId, policyConfig, options) {
        return (0, exports.PoliciesApiFp)(this.configuration)
            .policiesPolicyIdPut(policyId, policyConfig, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requests block ID from a policy by tag. Only users with the Root Authority and Installer roles are allowed to make the request.
     * @summary Requests block ID from a policy by tag.
     * @param {string} policyId Selected policy ID.
     * @param {string} tag Tag from the selected policy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    policiesPolicyIdTagTagGet(policyId, tag, options) {
        return (0, exports.PoliciesApiFp)(this.configuration)
            .policiesPolicyIdTagTagGet(policyId, tag, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new policy. Only users with the Root Authority role are allowed to make the request.
     * @summary Creates a new policy.
     * @param {PolicyConfig} policyConfig Object that contains policy configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    policiesPost(policyConfig, options) {
        return (0, exports.PoliciesApiFp)(this.configuration)
            .policiesPost(policyConfig, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Validates selected policy. Only users with the Root Authority role are allowed to make the request.
     * @summary Validates policy.
     * @param {PolicyConfig} policyConfig Object that contains policy configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    policiesValidatePost(policyConfig, options) {
        return (0, exports.PoliciesApiFp)(this.configuration)
            .policiesValidatePost(policyConfig, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.PoliciesApi = PoliciesApi;
/**
 * ProfilesApi - axios parameter creator
 * @export
 */
const ProfilesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Requests Hedera account balance. Only users with the Installer role are allowed to make the request.
         * @summary Returns user\'s Hedera account balance.
         * @param {string} username The name of the user for whom to fetch the balance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesUsernameBalanceGet: async (username, options = {}) => {
            // verify required parameter 'username' is not null or undefined
            (0, common_1.assertParamExists)('profilesUsernameBalanceGet', 'username', username);
            const localVarPath = `/profiles/{username}/balance`.replace(`{${'username'}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns user account information. For users with the Root Authority role it also returns address book and VC document information.
         * @summary Returns user account info.
         * @param {string} username The name of the user for whom to fetch the information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesUsernameGet: async (username, options = {}) => {
            // verify required parameter 'username' is not null or undefined
            (0, common_1.assertParamExists)('profilesUsernameGet', 'username', username);
            const localVarPath = `/profiles/{username}`.replace(`{${'username'}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets Hedera credentials for the user. For users with the Root Authority role it also creates an address book.
         * @summary Sets Hedera credentials for the user.
         * @param {string} username The name of the user for whom to update the information.
         * @param {User} user Object that contains the Hedera account data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesUsernamePut: async (username, user, options = {}) => {
            // verify required parameter 'username' is not null or undefined
            (0, common_1.assertParamExists)('profilesUsernamePut', 'username', username);
            // verify required parameter 'user' is not null or undefined
            (0, common_1.assertParamExists)('profilesUsernamePut', 'user', user);
            const localVarPath = `/profiles/{username}`.replace(`{${'username'}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'PUT',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(user, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ProfilesApiAxiosParamCreator = ProfilesApiAxiosParamCreator;
/**
 * ProfilesApi - functional programming interface
 * @export
 */
const ProfilesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ProfilesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Requests Hedera account balance. Only users with the Installer role are allowed to make the request.
         * @summary Returns user\'s Hedera account balance.
         * @param {string} username The name of the user for whom to fetch the balance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesUsernameBalanceGet(username, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesUsernameBalanceGet(username, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns user account information. For users with the Root Authority role it also returns address book and VC document information.
         * @summary Returns user account info.
         * @param {string} username The name of the user for whom to fetch the information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesUsernameGet(username, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesUsernameGet(username, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Sets Hedera credentials for the user. For users with the Root Authority role it also creates an address book.
         * @summary Sets Hedera credentials for the user.
         * @param {string} username The name of the user for whom to update the information.
         * @param {User} user Object that contains the Hedera account data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesUsernamePut(username, user, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesUsernamePut(username, user, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.ProfilesApiFp = ProfilesApiFp;
/**
 * ProfilesApi - factory interface
 * @export
 */
const ProfilesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ProfilesApiFp)(configuration);
    return {
        /**
         * Requests Hedera account balance. Only users with the Installer role are allowed to make the request.
         * @summary Returns user\'s Hedera account balance.
         * @param {string} username The name of the user for whom to fetch the balance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesUsernameBalanceGet(username, options) {
            return localVarFp
                .profilesUsernameBalanceGet(username, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns user account information. For users with the Root Authority role it also returns address book and VC document information.
         * @summary Returns user account info.
         * @param {string} username The name of the user for whom to fetch the information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesUsernameGet(username, options) {
            return localVarFp
                .profilesUsernameGet(username, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Sets Hedera credentials for the user. For users with the Root Authority role it also creates an address book.
         * @summary Sets Hedera credentials for the user.
         * @param {string} username The name of the user for whom to update the information.
         * @param {User} user Object that contains the Hedera account data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesUsernamePut(username, user, options) {
            return localVarFp
                .profilesUsernamePut(username, user, options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.ProfilesApiFactory = ProfilesApiFactory;
/**
 * ProfilesApi - object-oriented interface
 * @export
 * @class ProfilesApi
 * @extends {BaseAPI}
 */
class ProfilesApi extends base_1.BaseAPI {
    /**
     * Requests Hedera account balance. Only users with the Installer role are allowed to make the request.
     * @summary Returns user\'s Hedera account balance.
     * @param {string} username The name of the user for whom to fetch the balance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    profilesUsernameBalanceGet(username, options) {
        return (0, exports.ProfilesApiFp)(this.configuration)
            .profilesUsernameBalanceGet(username, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns user account information. For users with the Root Authority role it also returns address book and VC document information.
     * @summary Returns user account info.
     * @param {string} username The name of the user for whom to fetch the information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    profilesUsernameGet(username, options) {
        return (0, exports.ProfilesApiFp)(this.configuration)
            .profilesUsernameGet(username, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets Hedera credentials for the user. For users with the Root Authority role it also creates an address book.
     * @summary Sets Hedera credentials for the user.
     * @param {string} username The name of the user for whom to update the information.
     * @param {User} user Object that contains the Hedera account data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    profilesUsernamePut(username, user, options) {
        return (0, exports.ProfilesApiFp)(this.configuration)
            .profilesUsernamePut(username, user, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.ProfilesApi = ProfilesApi;
/**
 * SchemasApi - axios parameter creator
 * @export
 */
const SchemasApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns all schemas.
         * @summary Returns all schemas.
         * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
         * @param {number} [pageSize] The numbers of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemasGet: async (pageIndex, pageSize, options = {}) => {
            const localVarPath = `/schemas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (pageIndex !== undefined) {
                localVarQueryParameter['pageIndex'] = pageIndex;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Imports new schema from a zip file into the local DB. Only users with the Root Authority role are allowed to make the request.
         * @summary Imports new schema from a zip file.
         * @param {any} body A zip file containing schema to be imported.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        schemasImportFilePost: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('schemasImportFilePost', 'body', body);
            const localVarPath = `/schemas/import/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'binary/octet-stream';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Previews the schema from a zip file. Only users with the Root Authority role are allowed to make the request.
         * @summary Schema preview from a zip file.
         * @param {any} body A zip file containing the schema to be viewed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemasImportFilePreviewPost: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('schemasImportFilePreviewPost', 'body', body);
            const localVarPath = `/schemas/import/file/preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'binary/octet-stream';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Imports new schema from IPFS into the local DB. Only users with the Root Authority role are allowed to make the request.
         * @summary Imports new schema from IPFS.
         * @param {InlineObject1} inlineObject1
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        schemasImportMessagePost: async (inlineObject1, options = {}) => {
            // verify required parameter 'inlineObject1' is not null or undefined
            (0, common_1.assertParamExists)('schemasImportMessagePost', 'inlineObject1', inlineObject1);
            const localVarPath = `/schemas/import/message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(inlineObject1, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Previews the schema from IPFS without loading it into the local DB. Only users with the Root Authority role are allowed to make the request.
         * @summary Schema preview from IPFS.
         * @param {InlineObject3} inlineObject3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemasImportMessagePreviewPost: async (inlineObject3, options = {}) => {
            // verify required parameter 'inlineObject3' is not null or undefined
            (0, common_1.assertParamExists)('schemasImportMessagePreviewPost', 'inlineObject3', inlineObject3);
            const localVarPath = `/schemas/import/message/preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(inlineObject3, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates new schema. Only users with the Root Authority role are allowed to make the request.
         * @summary Create new schema.
         * @param {Schema} schema Object that contains a valid schema.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        schemasPost: async (schema, options = {}) => {
            // verify required parameter 'schema' is not null or undefined
            (0, common_1.assertParamExists)('schemasPost', 'schema', schema);
            const localVarPath = `/schemas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(schema, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the schema with the provided schema ID. Only users with the Root Authority role are allowed to make the request.
         * @summary Deletes the schema.
         * @param {string} schemaId Schema ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemasSchemaIdDelete: async (schemaId, options = {}) => {
            // verify required parameter 'schemaId' is not null or undefined
            (0, common_1.assertParamExists)('schemasSchemaIdDelete', 'schemaId', schemaId);
            const localVarPath = `/schemas/{schemaId}`.replace(`{${'schemaId'}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'DELETE',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns schema files for the schemas. Only users with the Root Authority role are allowed to make the request.
         * @summary Return zip file with schemas.
         * @param {string} schemaId Selected schema ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemasSchemaIdExportFilePost: async (schemaId, options = {}) => {
            // verify required parameter 'schemaId' is not null or undefined
            (0, common_1.assertParamExists)('schemasSchemaIdExportFilePost', 'schemaId', schemaId);
            const localVarPath = `/schemas/{schemaId}/export/file`.replace(`{${'schemaId'}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns Hedera message IDs of the published schemas, these messages contain IPFS CIDs of these schema files. Only users with the Root Authority role are allowed to make the request.
         * @summary List Hedera message IDs of published schemas.
         * @param {string} schemaId Selected schema ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemasSchemaIdExportMessagePost: async (schemaId, options = {}) => {
            // verify required parameter 'schemaId' is not null or undefined
            (0, common_1.assertParamExists)('schemasSchemaIdExportMessagePost', 'schemaId', schemaId);
            const localVarPath = `/schemas/{schemaId}/export/message`.replace(`{${'schemaId'}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Publishes the schema with the provided (internal) schema ID onto IPFS, sends a message featuring IPFS CID into the corresponding Hedera topic. Only users with the Root Authority role are allowed to make the request.
         * @summary Publishes the schema.
         * @param {string} schemaId Schema ID.
         * @param {InlineObject} inlineObject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemasSchemaIdPublishPut: async (schemaId, inlineObject, options = {}) => {
            // verify required parameter 'schemaId' is not null or undefined
            (0, common_1.assertParamExists)('schemasSchemaIdPublishPut', 'schemaId', schemaId);
            // verify required parameter 'inlineObject' is not null or undefined
            (0, common_1.assertParamExists)('schemasSchemaIdPublishPut', 'inlineObject', inlineObject);
            const localVarPath = `/schemas/{schemaId}/publish`.replace(`{${'schemaId'}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'PUT',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(inlineObject, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the schema with the provided schema ID. Only users with the Root Authority role are allowed to make the request.
         * @summary Updates the schema.
         * @param {string} schemaId Schema ID.
         * @param {Schema} schema Object that contains a valid schema.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemasSchemaIdPut: async (schemaId, schema, options = {}) => {
            // verify required parameter 'schemaId' is not null or undefined
            (0, common_1.assertParamExists)('schemasSchemaIdPut', 'schemaId', schemaId);
            // verify required parameter 'schema' is not null or undefined
            (0, common_1.assertParamExists)('schemasSchemaIdPut', 'schema', schema);
            const localVarPath = `/schemas/{schemaId}`.replace(`{${'schemaId'}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'PUT',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(schema, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all schemas by topicId.
         * @summary Returns all schemas by topicId.
         * @param {string} topicId Topic ID.
         * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
         * @param {number} [pageSize] The numbers of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemasTopicIdGet: async (topicId, pageIndex, pageSize, options = {}) => {
            // verify required parameter 'topicId' is not null or undefined
            (0, common_1.assertParamExists)('schemasTopicIdGet', 'topicId', topicId);
            const localVarPath = `/schemas/{topicId}`.replace(`{${'topicId'}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (pageIndex !== undefined) {
                localVarQueryParameter['pageIndex'] = pageIndex;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Imports new schema from a zip file into the local DB. Only users with the Root Authority role are allowed to make the request.
         * @summary Imports new schema from a zip file.
         * @param {string} topicId Topic ID.
         * @param {any} body A zip file containing schema to be imported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemasTopicIdImportFilePost: async (topicId, body, options = {}) => {
            // verify required parameter 'topicId' is not null or undefined
            (0, common_1.assertParamExists)('schemasTopicIdImportFilePost', 'topicId', topicId);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('schemasTopicIdImportFilePost', 'body', body);
            const localVarPath = `/schemas/{topicId}/import/file`.replace(`{${'topicId'}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'binary/octet-stream';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Imports new schema from IPFS into the local DB. Only users with the Root Authority role are allowed to make the request.
         * @summary Imports new schema from IPFS.
         * @param {string} topicId Topic ID.
         * @param {InlineObject2} inlineObject2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemasTopicIdImportMessagePost: async (topicId, inlineObject2, options = {}) => {
            // verify required parameter 'topicId' is not null or undefined
            (0, common_1.assertParamExists)('schemasTopicIdImportMessagePost', 'topicId', topicId);
            // verify required parameter 'inlineObject2' is not null or undefined
            (0, common_1.assertParamExists)('schemasTopicIdImportMessagePost', 'inlineObject2', inlineObject2);
            const localVarPath = `/schemas/{topicId}/import/message`.replace(`{${'topicId'}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(inlineObject2, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates new schema. Only users with the Root Authority role are allowed to make the request.
         * @summary Create new schema.
         * @param {string} topicId Topic ID.
         * @param {Schema} schema Object that contains a valid schema.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemasTopicIdPost: async (topicId, schema, options = {}) => {
            // verify required parameter 'topicId' is not null or undefined
            (0, common_1.assertParamExists)('schemasTopicIdPost', 'topicId', topicId);
            // verify required parameter 'schema' is not null or undefined
            (0, common_1.assertParamExists)('schemasTopicIdPost', 'schema', schema);
            const localVarPath = `/schemas/{topicId}`.replace(`{${'topicId'}}`, encodeURIComponent(String(topicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(schema, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.SchemasApiAxiosParamCreator = SchemasApiAxiosParamCreator;
/**
 * SchemasApi - functional programming interface
 * @export
 */
const SchemasApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.SchemasApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns all schemas.
         * @summary Returns all schemas.
         * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
         * @param {number} [pageSize] The numbers of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemasGet(pageIndex, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemasGet(pageIndex, pageSize, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Imports new schema from a zip file into the local DB. Only users with the Root Authority role are allowed to make the request.
         * @summary Imports new schema from a zip file.
         * @param {any} body A zip file containing schema to be imported.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async schemasImportFilePost(body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemasImportFilePost(body, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Previews the schema from a zip file. Only users with the Root Authority role are allowed to make the request.
         * @summary Schema preview from a zip file.
         * @param {any} body A zip file containing the schema to be viewed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemasImportFilePreviewPost(body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemasImportFilePreviewPost(body, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Imports new schema from IPFS into the local DB. Only users with the Root Authority role are allowed to make the request.
         * @summary Imports new schema from IPFS.
         * @param {InlineObject1} inlineObject1
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async schemasImportMessagePost(inlineObject1, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemasImportMessagePost(inlineObject1, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Previews the schema from IPFS without loading it into the local DB. Only users with the Root Authority role are allowed to make the request.
         * @summary Schema preview from IPFS.
         * @param {InlineObject3} inlineObject3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemasImportMessagePreviewPost(inlineObject3, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemasImportMessagePreviewPost(inlineObject3, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Creates new schema. Only users with the Root Authority role are allowed to make the request.
         * @summary Create new schema.
         * @param {Schema} schema Object that contains a valid schema.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async schemasPost(schema, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemasPost(schema, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Deletes the schema with the provided schema ID. Only users with the Root Authority role are allowed to make the request.
         * @summary Deletes the schema.
         * @param {string} schemaId Schema ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemasSchemaIdDelete(schemaId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemasSchemaIdDelete(schemaId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns schema files for the schemas. Only users with the Root Authority role are allowed to make the request.
         * @summary Return zip file with schemas.
         * @param {string} schemaId Selected schema ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemasSchemaIdExportFilePost(schemaId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemasSchemaIdExportFilePost(schemaId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns Hedera message IDs of the published schemas, these messages contain IPFS CIDs of these schema files. Only users with the Root Authority role are allowed to make the request.
         * @summary List Hedera message IDs of published schemas.
         * @param {string} schemaId Selected schema ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemasSchemaIdExportMessagePost(schemaId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemasSchemaIdExportMessagePost(schemaId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Publishes the schema with the provided (internal) schema ID onto IPFS, sends a message featuring IPFS CID into the corresponding Hedera topic. Only users with the Root Authority role are allowed to make the request.
         * @summary Publishes the schema.
         * @param {string} schemaId Schema ID.
         * @param {InlineObject} inlineObject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemasSchemaIdPublishPut(schemaId, inlineObject, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemasSchemaIdPublishPut(schemaId, inlineObject, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Updates the schema with the provided schema ID. Only users with the Root Authority role are allowed to make the request.
         * @summary Updates the schema.
         * @param {string} schemaId Schema ID.
         * @param {Schema} schema Object that contains a valid schema.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemasSchemaIdPut(schemaId, schema, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemasSchemaIdPut(schemaId, schema, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns all schemas by topicId.
         * @summary Returns all schemas by topicId.
         * @param {string} topicId Topic ID.
         * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
         * @param {number} [pageSize] The numbers of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemasTopicIdGet(topicId, pageIndex, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemasTopicIdGet(topicId, pageIndex, pageSize, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Imports new schema from a zip file into the local DB. Only users with the Root Authority role are allowed to make the request.
         * @summary Imports new schema from a zip file.
         * @param {string} topicId Topic ID.
         * @param {any} body A zip file containing schema to be imported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemasTopicIdImportFilePost(topicId, body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemasTopicIdImportFilePost(topicId, body, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Imports new schema from IPFS into the local DB. Only users with the Root Authority role are allowed to make the request.
         * @summary Imports new schema from IPFS.
         * @param {string} topicId Topic ID.
         * @param {InlineObject2} inlineObject2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemasTopicIdImportMessagePost(topicId, inlineObject2, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemasTopicIdImportMessagePost(topicId, inlineObject2, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Creates new schema. Only users with the Root Authority role are allowed to make the request.
         * @summary Create new schema.
         * @param {string} topicId Topic ID.
         * @param {Schema} schema Object that contains a valid schema.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemasTopicIdPost(topicId, schema, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemasTopicIdPost(topicId, schema, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.SchemasApiFp = SchemasApiFp;
/**
 * SchemasApi - factory interface
 * @export
 */
const SchemasApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.SchemasApiFp)(configuration);
    return {
        /**
         * Returns all schemas.
         * @summary Returns all schemas.
         * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
         * @param {number} [pageSize] The numbers of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemasGet(pageIndex, pageSize, options) {
            return localVarFp
                .schemasGet(pageIndex, pageSize, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Imports new schema from a zip file into the local DB. Only users with the Root Authority role are allowed to make the request.
         * @summary Imports new schema from a zip file.
         * @param {any} body A zip file containing schema to be imported.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        schemasImportFilePost(body, options) {
            return localVarFp
                .schemasImportFilePost(body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Previews the schema from a zip file. Only users with the Root Authority role are allowed to make the request.
         * @summary Schema preview from a zip file.
         * @param {any} body A zip file containing the schema to be viewed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemasImportFilePreviewPost(body, options) {
            return localVarFp
                .schemasImportFilePreviewPost(body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Imports new schema from IPFS into the local DB. Only users with the Root Authority role are allowed to make the request.
         * @summary Imports new schema from IPFS.
         * @param {InlineObject1} inlineObject1
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        schemasImportMessagePost(inlineObject1, options) {
            return localVarFp
                .schemasImportMessagePost(inlineObject1, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Previews the schema from IPFS without loading it into the local DB. Only users with the Root Authority role are allowed to make the request.
         * @summary Schema preview from IPFS.
         * @param {InlineObject3} inlineObject3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemasImportMessagePreviewPost(inlineObject3, options) {
            return localVarFp
                .schemasImportMessagePreviewPost(inlineObject3, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Creates new schema. Only users with the Root Authority role are allowed to make the request.
         * @summary Create new schema.
         * @param {Schema} schema Object that contains a valid schema.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        schemasPost(schema, options) {
            return localVarFp
                .schemasPost(schema, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Deletes the schema with the provided schema ID. Only users with the Root Authority role are allowed to make the request.
         * @summary Deletes the schema.
         * @param {string} schemaId Schema ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemasSchemaIdDelete(schemaId, options) {
            return localVarFp
                .schemasSchemaIdDelete(schemaId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns schema files for the schemas. Only users with the Root Authority role are allowed to make the request.
         * @summary Return zip file with schemas.
         * @param {string} schemaId Selected schema ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemasSchemaIdExportFilePost(schemaId, options) {
            return localVarFp
                .schemasSchemaIdExportFilePost(schemaId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns Hedera message IDs of the published schemas, these messages contain IPFS CIDs of these schema files. Only users with the Root Authority role are allowed to make the request.
         * @summary List Hedera message IDs of published schemas.
         * @param {string} schemaId Selected schema ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemasSchemaIdExportMessagePost(schemaId, options) {
            return localVarFp
                .schemasSchemaIdExportMessagePost(schemaId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Publishes the schema with the provided (internal) schema ID onto IPFS, sends a message featuring IPFS CID into the corresponding Hedera topic. Only users with the Root Authority role are allowed to make the request.
         * @summary Publishes the schema.
         * @param {string} schemaId Schema ID.
         * @param {InlineObject} inlineObject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemasSchemaIdPublishPut(schemaId, inlineObject, options) {
            return localVarFp
                .schemasSchemaIdPublishPut(schemaId, inlineObject, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Updates the schema with the provided schema ID. Only users with the Root Authority role are allowed to make the request.
         * @summary Updates the schema.
         * @param {string} schemaId Schema ID.
         * @param {Schema} schema Object that contains a valid schema.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemasSchemaIdPut(schemaId, schema, options) {
            return localVarFp
                .schemasSchemaIdPut(schemaId, schema, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns all schemas by topicId.
         * @summary Returns all schemas by topicId.
         * @param {string} topicId Topic ID.
         * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
         * @param {number} [pageSize] The numbers of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemasTopicIdGet(topicId, pageIndex, pageSize, options) {
            return localVarFp
                .schemasTopicIdGet(topicId, pageIndex, pageSize, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Imports new schema from a zip file into the local DB. Only users with the Root Authority role are allowed to make the request.
         * @summary Imports new schema from a zip file.
         * @param {string} topicId Topic ID.
         * @param {any} body A zip file containing schema to be imported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemasTopicIdImportFilePost(topicId, body, options) {
            return localVarFp
                .schemasTopicIdImportFilePost(topicId, body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Imports new schema from IPFS into the local DB. Only users with the Root Authority role are allowed to make the request.
         * @summary Imports new schema from IPFS.
         * @param {string} topicId Topic ID.
         * @param {InlineObject2} inlineObject2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemasTopicIdImportMessagePost(topicId, inlineObject2, options) {
            return localVarFp
                .schemasTopicIdImportMessagePost(topicId, inlineObject2, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Creates new schema. Only users with the Root Authority role are allowed to make the request.
         * @summary Create new schema.
         * @param {string} topicId Topic ID.
         * @param {Schema} schema Object that contains a valid schema.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemasTopicIdPost(topicId, schema, options) {
            return localVarFp
                .schemasTopicIdPost(topicId, schema, options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.SchemasApiFactory = SchemasApiFactory;
/**
 * SchemasApi - object-oriented interface
 * @export
 * @class SchemasApi
 * @extends {BaseAPI}
 */
class SchemasApi extends base_1.BaseAPI {
    /**
     * Returns all schemas.
     * @summary Returns all schemas.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    schemasGet(pageIndex, pageSize, options) {
        return (0, exports.SchemasApiFp)(this.configuration)
            .schemasGet(pageIndex, pageSize, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Imports new schema from a zip file into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Imports new schema from a zip file.
     * @param {any} body A zip file containing schema to be imported.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    schemasImportFilePost(body, options) {
        return (0, exports.SchemasApiFp)(this.configuration)
            .schemasImportFilePost(body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Previews the schema from a zip file. Only users with the Root Authority role are allowed to make the request.
     * @summary Schema preview from a zip file.
     * @param {any} body A zip file containing the schema to be viewed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    schemasImportFilePreviewPost(body, options) {
        return (0, exports.SchemasApiFp)(this.configuration)
            .schemasImportFilePreviewPost(body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Imports new schema from IPFS into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Imports new schema from IPFS.
     * @param {InlineObject1} inlineObject1
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    schemasImportMessagePost(inlineObject1, options) {
        return (0, exports.SchemasApiFp)(this.configuration)
            .schemasImportMessagePost(inlineObject1, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Previews the schema from IPFS without loading it into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Schema preview from IPFS.
     * @param {InlineObject3} inlineObject3
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    schemasImportMessagePreviewPost(inlineObject3, options) {
        return (0, exports.SchemasApiFp)(this.configuration)
            .schemasImportMessagePreviewPost(inlineObject3, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates new schema. Only users with the Root Authority role are allowed to make the request.
     * @summary Create new schema.
     * @param {Schema} schema Object that contains a valid schema.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    schemasPost(schema, options) {
        return (0, exports.SchemasApiFp)(this.configuration)
            .schemasPost(schema, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes the schema with the provided schema ID. Only users with the Root Authority role are allowed to make the request.
     * @summary Deletes the schema.
     * @param {string} schemaId Schema ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    schemasSchemaIdDelete(schemaId, options) {
        return (0, exports.SchemasApiFp)(this.configuration)
            .schemasSchemaIdDelete(schemaId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns schema files for the schemas. Only users with the Root Authority role are allowed to make the request.
     * @summary Return zip file with schemas.
     * @param {string} schemaId Selected schema ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    schemasSchemaIdExportFilePost(schemaId, options) {
        return (0, exports.SchemasApiFp)(this.configuration)
            .schemasSchemaIdExportFilePost(schemaId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns Hedera message IDs of the published schemas, these messages contain IPFS CIDs of these schema files. Only users with the Root Authority role are allowed to make the request.
     * @summary List Hedera message IDs of published schemas.
     * @param {string} schemaId Selected schema ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    schemasSchemaIdExportMessagePost(schemaId, options) {
        return (0, exports.SchemasApiFp)(this.configuration)
            .schemasSchemaIdExportMessagePost(schemaId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Publishes the schema with the provided (internal) schema ID onto IPFS, sends a message featuring IPFS CID into the corresponding Hedera topic. Only users with the Root Authority role are allowed to make the request.
     * @summary Publishes the schema.
     * @param {string} schemaId Schema ID.
     * @param {InlineObject} inlineObject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    schemasSchemaIdPublishPut(schemaId, inlineObject, options) {
        return (0, exports.SchemasApiFp)(this.configuration)
            .schemasSchemaIdPublishPut(schemaId, inlineObject, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the schema with the provided schema ID. Only users with the Root Authority role are allowed to make the request.
     * @summary Updates the schema.
     * @param {string} schemaId Schema ID.
     * @param {Schema} schema Object that contains a valid schema.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    schemasSchemaIdPut(schemaId, schema, options) {
        return (0, exports.SchemasApiFp)(this.configuration)
            .schemasSchemaIdPut(schemaId, schema, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all schemas by topicId.
     * @summary Returns all schemas by topicId.
     * @param {string} topicId Topic ID.
     * @param {number} [pageIndex] The number of pages to skip before starting to collect the result set
     * @param {number} [pageSize] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    schemasTopicIdGet(topicId, pageIndex, pageSize, options) {
        return (0, exports.SchemasApiFp)(this.configuration)
            .schemasTopicIdGet(topicId, pageIndex, pageSize, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Imports new schema from a zip file into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Imports new schema from a zip file.
     * @param {string} topicId Topic ID.
     * @param {any} body A zip file containing schema to be imported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    schemasTopicIdImportFilePost(topicId, body, options) {
        return (0, exports.SchemasApiFp)(this.configuration)
            .schemasTopicIdImportFilePost(topicId, body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Imports new schema from IPFS into the local DB. Only users with the Root Authority role are allowed to make the request.
     * @summary Imports new schema from IPFS.
     * @param {string} topicId Topic ID.
     * @param {InlineObject2} inlineObject2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    schemasTopicIdImportMessagePost(topicId, inlineObject2, options) {
        return (0, exports.SchemasApiFp)(this.configuration)
            .schemasTopicIdImportMessagePost(topicId, inlineObject2, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates new schema. Only users with the Root Authority role are allowed to make the request.
     * @summary Create new schema.
     * @param {string} topicId Topic ID.
     * @param {Schema} schema Object that contains a valid schema.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    schemasTopicIdPost(topicId, schema, options) {
        return (0, exports.SchemasApiFp)(this.configuration)
            .schemasTopicIdPost(topicId, schema, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.SchemasApi = SchemasApi;
/**
 * SettingsApi - axios parameter creator
 * @export
 */
const SettingsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns current settings. For users with the Root Authority role only.
         * @summary Returns current settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsGet: async (options = {}) => {
            const localVarPath = `/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set settings. For users with the Root Authority role only.
         * @summary Set settings.
         * @param {CommonSettings} commonSettings Settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsPost: async (commonSettings, options = {}) => {
            // verify required parameter 'commonSettings' is not null or undefined
            (0, common_1.assertParamExists)('settingsPost', 'commonSettings', commonSettings);
            const localVarPath = `/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(commonSettings, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.SettingsApiAxiosParamCreator = SettingsApiAxiosParamCreator;
/**
 * SettingsApi - functional programming interface
 * @export
 */
const SettingsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.SettingsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns current settings. For users with the Root Authority role only.
         * @summary Returns current settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsGet(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsGet(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Set settings. For users with the Root Authority role only.
         * @summary Set settings.
         * @param {CommonSettings} commonSettings Settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsPost(commonSettings, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsPost(commonSettings, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.SettingsApiFp = SettingsApiFp;
/**
 * SettingsApi - factory interface
 * @export
 */
const SettingsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.SettingsApiFp)(configuration);
    return {
        /**
         * Returns current settings. For users with the Root Authority role only.
         * @summary Returns current settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsGet(options) {
            return localVarFp
                .settingsGet(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Set settings. For users with the Root Authority role only.
         * @summary Set settings.
         * @param {CommonSettings} commonSettings Settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsPost(commonSettings, options) {
            return localVarFp
                .settingsPost(commonSettings, options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.SettingsApiFactory = SettingsApiFactory;
/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
class SettingsApi extends base_1.BaseAPI {
    /**
     * Returns current settings. For users with the Root Authority role only.
     * @summary Returns current settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    settingsGet(options) {
        return (0, exports.SettingsApiFp)(this.configuration)
            .settingsGet(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Set settings. For users with the Root Authority role only.
     * @summary Set settings.
     * @param {CommonSettings} commonSettings Settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    settingsPost(commonSettings, options) {
        return (0, exports.SettingsApiFp)(this.configuration)
            .settingsPost(commonSettings, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.SettingsApi = SettingsApi;
/**
 * TokensApi - axios parameter creator
 * @export
 */
const TokensApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns all tokens. For the Root Authority role it returns only the list of tokens, for other users it also returns token balances as well as the KYC, Freeze, and Association statuses. Not allowed for the Auditor role.
         * @summary Return a list of tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet: async (options = {}) => {
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new token. Only users with the Root Authority role are allowed to make the request.
         * @summary Creates a new token.
         * @param {Token} token Object that contains token information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensPost: async (token, options = {}) => {
            // verify required parameter 'token' is not null or undefined
            (0, common_1.assertParamExists)('tokensPost', 'token', token);
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'POST',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(token, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Associates the user with the provided Hedera token. Only users with the Installer role are allowed to make the request.
         * @summary Associates the user with the provided Hedera token.
         * @param {string} tokenId Token ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensTokenIdAssociatePut: async (tokenId, options = {}) => {
            // verify required parameter 'tokenId' is not null or undefined
            (0, common_1.assertParamExists)('tokensTokenIdAssociatePut', 'tokenId', tokenId);
            const localVarPath = `/tokens/{tokenId}/associate`.replace(`{${'tokenId'}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'PUT',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disassociates the user with the provided Hedera token. Only users with the Installer role are allowed to make the request.
         * @summary Associate the user with the provided Hedera token.
         * @param {string} tokenId Token ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensTokenIdDissociatePut: async (tokenId, options = {}) => {
            // verify required parameter 'tokenId' is not null or undefined
            (0, common_1.assertParamExists)('tokensTokenIdDissociatePut', 'tokenId', tokenId);
            const localVarPath = `/tokens/{tokenId}/dissociate`.replace(`{${'tokenId'}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'PUT',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Freezes transfers of the specified token for the user. Only users with the Root Authority role are allowed to make the request.
         * @summary Freeze transfers of the specified token for the user.
         * @param {string} tokenId Token ID.
         * @param {string} username Username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensTokenIdUsernameFreezePut: async (tokenId, username, options = {}) => {
            // verify required parameter 'tokenId' is not null or undefined
            (0, common_1.assertParamExists)('tokensTokenIdUsernameFreezePut', 'tokenId', tokenId);
            // verify required parameter 'username' is not null or undefined
            (0, common_1.assertParamExists)('tokensTokenIdUsernameFreezePut', 'username', username);
            const localVarPath = `/tokens/{tokenId}/{username}/freeze`
                .replace(`{${'tokenId'}}`, encodeURIComponent(String(tokenId)))
                .replace(`{${'username'}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'PUT',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the KYC flag for the user. Only users with the Root Authority role are allowed to make the request.
         * @summary Sets the KYC flag for the user.
         * @param {string} tokenId Token ID.
         * @param {string} username Username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensTokenIdUsernameGrantKycPut: async (tokenId, username, options = {}) => {
            // verify required parameter 'tokenId' is not null or undefined
            (0, common_1.assertParamExists)('tokensTokenIdUsernameGrantKycPut', 'tokenId', tokenId);
            // verify required parameter 'username' is not null or undefined
            (0, common_1.assertParamExists)('tokensTokenIdUsernameGrantKycPut', 'username', username);
            const localVarPath = `/tokens/{tokenId}/{username}/grantKyc`
                .replace(`{${'tokenId'}}`, encodeURIComponent(String(tokenId)))
                .replace(`{${'username'}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'PUT',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns user information for the selected token. Only users with the Root Authority role are allowed to make the request.
         * @param {string} tokenId Token ID.
         * @param {string} username Username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensTokenIdUsernameInfoGet: async (tokenId, username, options = {}) => {
            // verify required parameter 'tokenId' is not null or undefined
            (0, common_1.assertParamExists)('tokensTokenIdUsernameInfoGet', 'tokenId', tokenId);
            // verify required parameter 'username' is not null or undefined
            (0, common_1.assertParamExists)('tokensTokenIdUsernameInfoGet', 'username', username);
            const localVarPath = `/tokens/{tokenId}/{username}/info`
                .replace(`{${'tokenId'}}`, encodeURIComponent(String(tokenId)))
                .replace(`{${'username'}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unsets the KYC flag for the user. Only users with the Root Authority role are allowed to make the request.
         * @summary Unsets the KYC flag for the user.
         * @param {string} tokenId Token ID.
         * @param {string} username Username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensTokenIdUsernameRevokeKycPut: async (tokenId, username, options = {}) => {
            // verify required parameter 'tokenId' is not null or undefined
            (0, common_1.assertParamExists)('tokensTokenIdUsernameRevokeKycPut', 'tokenId', tokenId);
            // verify required parameter 'username' is not null or undefined
            (0, common_1.assertParamExists)('tokensTokenIdUsernameRevokeKycPut', 'username', username);
            const localVarPath = `/tokens/{tokenId}/{username}/revokeKyc`
                .replace(`{${'tokenId'}}`, encodeURIComponent(String(tokenId)))
                .replace(`{${'username'}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'PUT',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unfreezes transfers of the specified token for the user. Only users with the Root Authority role are allowed to make the request.
         * @summary Unfreezes transfers of the specified token for the user.
         * @param {string} tokenId Token ID.
         * @param {string} username Username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensTokenIdUsernameUnfreezePut: async (tokenId, username, options = {}) => {
            // verify required parameter 'tokenId' is not null or undefined
            (0, common_1.assertParamExists)('tokensTokenIdUsernameUnfreezePut', 'tokenId', tokenId);
            // verify required parameter 'username' is not null or undefined
            (0, common_1.assertParamExists)('tokensTokenIdUsernameUnfreezePut', 'username', username);
            const localVarPath = `/tokens/{tokenId}/{username}/unfreeze`
                .replace(`{${'tokenId'}}`, encodeURIComponent(String(tokenId)))
                .replace(`{${'username'}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'PUT',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.TokensApiAxiosParamCreator = TokensApiAxiosParamCreator;
/**
 * TokensApi - functional programming interface
 * @export
 */
const TokensApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TokensApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns all tokens. For the Root Authority role it returns only the list of tokens, for other users it also returns token balances as well as the KYC, Freeze, and Association statuses. Not allowed for the Auditor role.
         * @summary Return a list of tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensGet(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensGet(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Creates a new token. Only users with the Root Authority role are allowed to make the request.
         * @summary Creates a new token.
         * @param {Token} token Object that contains token information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensPost(token, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensPost(token, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Associates the user with the provided Hedera token. Only users with the Installer role are allowed to make the request.
         * @summary Associates the user with the provided Hedera token.
         * @param {string} tokenId Token ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensTokenIdAssociatePut(tokenId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensTokenIdAssociatePut(tokenId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Disassociates the user with the provided Hedera token. Only users with the Installer role are allowed to make the request.
         * @summary Associate the user with the provided Hedera token.
         * @param {string} tokenId Token ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensTokenIdDissociatePut(tokenId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensTokenIdDissociatePut(tokenId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Freezes transfers of the specified token for the user. Only users with the Root Authority role are allowed to make the request.
         * @summary Freeze transfers of the specified token for the user.
         * @param {string} tokenId Token ID.
         * @param {string} username Username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensTokenIdUsernameFreezePut(tokenId, username, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensTokenIdUsernameFreezePut(tokenId, username, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Sets the KYC flag for the user. Only users with the Root Authority role are allowed to make the request.
         * @summary Sets the KYC flag for the user.
         * @param {string} tokenId Token ID.
         * @param {string} username Username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensTokenIdUsernameGrantKycPut(tokenId, username, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensTokenIdUsernameGrantKycPut(tokenId, username, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns user information for the selected token. Only users with the Root Authority role are allowed to make the request.
         * @param {string} tokenId Token ID.
         * @param {string} username Username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensTokenIdUsernameInfoGet(tokenId, username, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensTokenIdUsernameInfoGet(tokenId, username, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Unsets the KYC flag for the user. Only users with the Root Authority role are allowed to make the request.
         * @summary Unsets the KYC flag for the user.
         * @param {string} tokenId Token ID.
         * @param {string} username Username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensTokenIdUsernameRevokeKycPut(tokenId, username, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensTokenIdUsernameRevokeKycPut(tokenId, username, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Unfreezes transfers of the specified token for the user. Only users with the Root Authority role are allowed to make the request.
         * @summary Unfreezes transfers of the specified token for the user.
         * @param {string} tokenId Token ID.
         * @param {string} username Username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensTokenIdUsernameUnfreezePut(tokenId, username, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensTokenIdUsernameUnfreezePut(tokenId, username, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.TokensApiFp = TokensApiFp;
/**
 * TokensApi - factory interface
 * @export
 */
const TokensApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TokensApiFp)(configuration);
    return {
        /**
         * Returns all tokens. For the Root Authority role it returns only the list of tokens, for other users it also returns token balances as well as the KYC, Freeze, and Association statuses. Not allowed for the Auditor role.
         * @summary Return a list of tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet(options) {
            return localVarFp
                .tokensGet(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Creates a new token. Only users with the Root Authority role are allowed to make the request.
         * @summary Creates a new token.
         * @param {Token} token Object that contains token information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensPost(token, options) {
            return localVarFp
                .tokensPost(token, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Associates the user with the provided Hedera token. Only users with the Installer role are allowed to make the request.
         * @summary Associates the user with the provided Hedera token.
         * @param {string} tokenId Token ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensTokenIdAssociatePut(tokenId, options) {
            return localVarFp
                .tokensTokenIdAssociatePut(tokenId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Disassociates the user with the provided Hedera token. Only users with the Installer role are allowed to make the request.
         * @summary Associate the user with the provided Hedera token.
         * @param {string} tokenId Token ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensTokenIdDissociatePut(tokenId, options) {
            return localVarFp
                .tokensTokenIdDissociatePut(tokenId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Freezes transfers of the specified token for the user. Only users with the Root Authority role are allowed to make the request.
         * @summary Freeze transfers of the specified token for the user.
         * @param {string} tokenId Token ID.
         * @param {string} username Username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensTokenIdUsernameFreezePut(tokenId, username, options) {
            return localVarFp
                .tokensTokenIdUsernameFreezePut(tokenId, username, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Sets the KYC flag for the user. Only users with the Root Authority role are allowed to make the request.
         * @summary Sets the KYC flag for the user.
         * @param {string} tokenId Token ID.
         * @param {string} username Username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensTokenIdUsernameGrantKycPut(tokenId, username, options) {
            return localVarFp
                .tokensTokenIdUsernameGrantKycPut(tokenId, username, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns user information for the selected token. Only users with the Root Authority role are allowed to make the request.
         * @param {string} tokenId Token ID.
         * @param {string} username Username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensTokenIdUsernameInfoGet(tokenId, username, options) {
            return localVarFp
                .tokensTokenIdUsernameInfoGet(tokenId, username, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Unsets the KYC flag for the user. Only users with the Root Authority role are allowed to make the request.
         * @summary Unsets the KYC flag for the user.
         * @param {string} tokenId Token ID.
         * @param {string} username Username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensTokenIdUsernameRevokeKycPut(tokenId, username, options) {
            return localVarFp
                .tokensTokenIdUsernameRevokeKycPut(tokenId, username, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Unfreezes transfers of the specified token for the user. Only users with the Root Authority role are allowed to make the request.
         * @summary Unfreezes transfers of the specified token for the user.
         * @param {string} tokenId Token ID.
         * @param {string} username Username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensTokenIdUsernameUnfreezePut(tokenId, username, options) {
            return localVarFp
                .tokensTokenIdUsernameUnfreezePut(tokenId, username, options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.TokensApiFactory = TokensApiFactory;
/**
 * TokensApi - object-oriented interface
 * @export
 * @class TokensApi
 * @extends {BaseAPI}
 */
class TokensApi extends base_1.BaseAPI {
    /**
     * Returns all tokens. For the Root Authority role it returns only the list of tokens, for other users it also returns token balances as well as the KYC, Freeze, and Association statuses. Not allowed for the Auditor role.
     * @summary Return a list of tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    tokensGet(options) {
        return (0, exports.TokensApiFp)(this.configuration)
            .tokensGet(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new token. Only users with the Root Authority role are allowed to make the request.
     * @summary Creates a new token.
     * @param {Token} token Object that contains token information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    tokensPost(token, options) {
        return (0, exports.TokensApiFp)(this.configuration)
            .tokensPost(token, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Associates the user with the provided Hedera token. Only users with the Installer role are allowed to make the request.
     * @summary Associates the user with the provided Hedera token.
     * @param {string} tokenId Token ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    tokensTokenIdAssociatePut(tokenId, options) {
        return (0, exports.TokensApiFp)(this.configuration)
            .tokensTokenIdAssociatePut(tokenId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Disassociates the user with the provided Hedera token. Only users with the Installer role are allowed to make the request.
     * @summary Associate the user with the provided Hedera token.
     * @param {string} tokenId Token ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    tokensTokenIdDissociatePut(tokenId, options) {
        return (0, exports.TokensApiFp)(this.configuration)
            .tokensTokenIdDissociatePut(tokenId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Freezes transfers of the specified token for the user. Only users with the Root Authority role are allowed to make the request.
     * @summary Freeze transfers of the specified token for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    tokensTokenIdUsernameFreezePut(tokenId, username, options) {
        return (0, exports.TokensApiFp)(this.configuration)
            .tokensTokenIdUsernameFreezePut(tokenId, username, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets the KYC flag for the user. Only users with the Root Authority role are allowed to make the request.
     * @summary Sets the KYC flag for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    tokensTokenIdUsernameGrantKycPut(tokenId, username, options) {
        return (0, exports.TokensApiFp)(this.configuration)
            .tokensTokenIdUsernameGrantKycPut(tokenId, username, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns user information for the selected token. Only users with the Root Authority role are allowed to make the request.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    tokensTokenIdUsernameInfoGet(tokenId, username, options) {
        return (0, exports.TokensApiFp)(this.configuration)
            .tokensTokenIdUsernameInfoGet(tokenId, username, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Unsets the KYC flag for the user. Only users with the Root Authority role are allowed to make the request.
     * @summary Unsets the KYC flag for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    tokensTokenIdUsernameRevokeKycPut(tokenId, username, options) {
        return (0, exports.TokensApiFp)(this.configuration)
            .tokensTokenIdUsernameRevokeKycPut(tokenId, username, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Unfreezes transfers of the specified token for the user. Only users with the Root Authority role are allowed to make the request.
     * @summary Unfreezes transfers of the specified token for the user.
     * @param {string} tokenId Token ID.
     * @param {string} username Username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    tokensTokenIdUsernameUnfreezePut(tokenId, username, options) {
        return (0, exports.TokensApiFp)(this.configuration)
            .tokensTokenIdUsernameUnfreezePut(tokenId, username, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.TokensApi = TokensApi;
/**
 * TrustchainsApi - axios parameter creator
 * @export
 */
const TrustchainsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Requests all VP documents. Only users with the Auditor role are allowed to make the request.
         * @summary Returns a list of all VP documents.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trustchainsGet: async (options = {}) => {
            const localVarPath = `/trustchains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Builds and returns a trustchain, from the VP to the root VC document. Only users with the Auditor role are allowed to make the request.
         * @summary Returns a trustchain for a VP document.
         * @param {string} hash Hash or ID of a VP document.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trustchainsHashGet: async (hash, options = {}) => {
            // verify required parameter 'hash' is not null or undefined
            (0, common_1.assertParamExists)('trustchainsHashGet', 'hash', hash);
            const localVarPath = `/trustchains/{hash}`.replace(`{${'hash'}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: 'GET',
                ...baseOptions,
                ...options,
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.TrustchainsApiAxiosParamCreator = TrustchainsApiAxiosParamCreator;
/**
 * TrustchainsApi - functional programming interface
 * @export
 */
const TrustchainsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TrustchainsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Requests all VP documents. Only users with the Auditor role are allowed to make the request.
         * @summary Returns a list of all VP documents.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trustchainsGet(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trustchainsGet(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Builds and returns a trustchain, from the VP to the root VC document. Only users with the Auditor role are allowed to make the request.
         * @summary Returns a trustchain for a VP document.
         * @param {string} hash Hash or ID of a VP document.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trustchainsHashGet(hash, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trustchainsHashGet(hash, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.TrustchainsApiFp = TrustchainsApiFp;
/**
 * TrustchainsApi - factory interface
 * @export
 */
const TrustchainsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TrustchainsApiFp)(configuration);
    return {
        /**
         * Requests all VP documents. Only users with the Auditor role are allowed to make the request.
         * @summary Returns a list of all VP documents.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trustchainsGet(options) {
            return localVarFp
                .trustchainsGet(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Builds and returns a trustchain, from the VP to the root VC document. Only users with the Auditor role are allowed to make the request.
         * @summary Returns a trustchain for a VP document.
         * @param {string} hash Hash or ID of a VP document.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trustchainsHashGet(hash, options) {
            return localVarFp
                .trustchainsHashGet(hash, options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.TrustchainsApiFactory = TrustchainsApiFactory;
/**
 * TrustchainsApi - object-oriented interface
 * @export
 * @class TrustchainsApi
 * @extends {BaseAPI}
 */
class TrustchainsApi extends base_1.BaseAPI {
    /**
     * Requests all VP documents. Only users with the Auditor role are allowed to make the request.
     * @summary Returns a list of all VP documents.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrustchainsApi
     */
    trustchainsGet(options) {
        return (0, exports.TrustchainsApiFp)(this.configuration)
            .trustchainsGet(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Builds and returns a trustchain, from the VP to the root VC document. Only users with the Auditor role are allowed to make the request.
     * @summary Returns a trustchain for a VP document.
     * @param {string} hash Hash or ID of a VP document.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrustchainsApi
     */
    trustchainsHashGet(hash, options) {
        return (0, exports.TrustchainsApiFp)(this.configuration)
            .trustchainsHashGet(hash, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.TrustchainsApi = TrustchainsApi;
//# sourceMappingURL=api.js.map